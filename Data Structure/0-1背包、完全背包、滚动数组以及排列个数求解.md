# 背包问题（Knapsack problem）

背包问题（Knapsack Problem）在计算机科学和运筹学中是一类经典的优化问题。这个问题来源于一个简单的比喻：假设你有一个背包，这个背包有一定的**容量限制**；现在有一组物品，每个物品有自己的**体积和价值**。目标是在不超过背包容量限制的情况下，选择装入哪些物品能够使得背包中物品的总价值最大化。

通过动态规划的方法可以在有限的时间内有效地解决背包问题。动态规划通过构建**一维或者多维数组**来记录不同容量下能达到的最大价值，从而逐步求解出最终答案。此外，也可以使用启发式算法或近似算法来处理更大规模的问题，以获得接近最优解的结果。

在本文中仅介绍通过动态规划解决背包问题的算法。

## 1 0-1背包问题

我个人更喜欢描述成背包的**容量限制**，而每个物品都是有**体积**的，你塞了一些物品进去，剩下的物品塞不进去了。就好像出去旅游，背包大小总是有限的，那么选择放入哪些物品，才能最大化的利用这个空间，就是我们所讨论的0-1背包问题。当然具体采用什么描述都是随心而定的，也得看具体的问题进行解释。

求解0-1背包问题的步骤大致可以分为以下几步。

### 1.1 确定 `dp[i][j]` 的含义

假设背包的最大容量为 `capacity`，每个物品的体积和价值分别保存在数组 `volume` 和 `value` 中，数组长度为 `m`。我们定义二维数组 `dp`，其一维大小是 `m + 1`，二维大小是 `capacity + 1`。其中 `dp[i][j]` 表示**背包容量为 `j` 时，从前 i 个物品（索引值在 `[1, i]`）中选择可以得到的最大价值**。则最终结果就是 `d[m][capacity]`。

举个例子： `d[2][3] = 5` 表明背包容量为3时，从索引值在 `[0, 2]` 中的物品进行选择可以得到的最大价值为5。

题目不同，`dp[i][j]` 的具体含义也会相应的发生变化。

### 1.2 确定边界条件

当 `i = 0` 时，表示没有任何物品可以选择，对应的最大价值也是0，因此边界条件是：

$$dp[0][j]=0\ (0 <= j <= capacity)$$

题目不同，边界条件也会相应的发生变化。

### 1.3 确定 `dp` 的计算顺序和状态转移方程

计算 `dp` 的整个过程是**由左至右**，**由上至下**的。

当 `1 <= i <= m` 时，对于数组 `volume` 中的第 `i` 个元素 `volume[i - 1]`（如果 `volume` 数组从1开始计数就是 `volume[i]`），遍历 `0 <= j <= capacity`，计算 `dp[i][j]` 的值：
1. 如果 `j < volume[i - 1]`，说明背包装不进物品 `i`，此时有 `dp[i][j] = dp[i−1][j]`；
2. 如果 `j >= volume[i - 1]`，说明背包可以装入物品 `i`，此时求**最大价值**就存在两个方案：
   - 不放物品 `i`，问题转变为背包容量为 `j` 时，从前 `i - 1` 个物品中选择可以得到的最大价值，即 `dp[i - 1][j]`。
   - 放入物品 `i`，背包容量变小了，问题转变为背包容量为 `j - volume[i - 1]` 时，从前 `i - 1` 个物品中选择可以得到的最大价值。因为物品 `i` 本身存在价值，所以最大价值为 `dp[i - 1][j - volume[i - 1]] + value[i - 1]`。

最后的 `dp[i][j]`，应该是这两个方案下的最大值，故状态转移方程如下：

$$dp[i][j]= \left\lbrace\begin{array}{ll}
dp[i - 1][j], & j < volume[i - 1] \\
max(dp[i - 1][j],\ dp[i - 1][j - volume[i - 1]] + value[i - 1]), & j \geq volume[i - 1]
\end{array}\right.$$

### 1.4 求0-1背包问题的 C++ 算法代码

```cpp
int KnapsackProblem(vector<int>& volume, vector<int>& value, int capacity)
{
    int m = volume.size();
    vector<vector<int>> dp(m + 1, vector<int>(capacity + 1, 0));
    for (int i = 1; i <= m; ++i)    // 从前 i 个物品中选择
    {
        for (int j = 0; j <= capacity; ++j)    // j 遍历背包容量
        {
            if (j < volume[i - 1]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - volume[i - 1]] + value[i - 1]);
        }
    }

    return dp[m][capacity];
}
```

## 2 利用滚动数组优化0-1背包问题

由于 `dp[i][]` 的每个元素值的计算只和 `dp[i - 1][]` 的元素值有关，因此可以使用滚动数组的方式，去掉 `dp` 的第一个维度。此时对于 `volume` 数组。我们需要遍历 `0 <= i < m`，由转移方程：

$$dp[i][j] = dp[i - 1][j]$$

如果内层循环仍采用顺序遍历，在计算 `dp[j]` 时会发现，`dp[j − volume[i]]` 的值已经被覆盖了。因为 `dp[j − volume[i]]` 实际对应的是原二维数组中 `dp[i - 1][j − volume[i - 1]]` 的值，这样得到的最大价值是不对的。采用倒序遍历就可以防止这种问题的出现。

读者不要产生误解，我们的循环仍然是**双层循环**，只不过是将物品这一维抽取了出来。从而状态转移方程可以改为：

$$dp[j] = max(dp[j],\ dp[j - volume[i]] + value[i])$$

但是要注意的，改成一维后，`dp[j]` 含义就变成了：背包容量为 `j` 时可以得到的最大价值，不再与物品的种类进行关联了。这样做有好有坏，好处是我们直接得到了在各个容量值下，从**所有物品**中选择可以得到的**最大价值**；坏处是损失了从**部分物品**中选择可以得到的最大价值的数据。

因为采用这种方法后，每经过一次外层循环，`dp` 中的值会全都更新一次（有可能值保持不变），因此得名**滚动数组**。

```cpp
int KnapsackProblem(vector<int>& volume, vector<int>& value, int capacity)
{
    vector<int> dp(capacity + 1, 0);
    for (int i = 0; i < volume.size(); ++i) // 从前 i 个物品中选择
        for (int j = volume[i]; j >= volume[i]; --j)    // j 遍历背包容量
            dp[j] = max(dp[j], dp[j - volume[i]] + value[i]);

    return dp[capacity];
}
```

## 3 完全背包问题

完全背包问题，就是在0-1问题的基础上，将条件“每个物品只有一个”改成“每个物品有无数个”，从而可以重复的进行选择。其解题思路和0-1背包问题是一样的，唯一的区别在于物品的选择。在0-1背包问题中，我们有两种方案：选择和不选择。在完全背包问题中就变成了：**选择同一个物品多次**和**不选择**。

### 3.1 求完全背包问题的 C++ 算法代码

当 `1 <= i <= m` 时，对于数组 `volume` 中的第 `i` 个元素 `volume[i - 1]`（如果 `volume` 数组从1开始计数就是 `volume[i]`），遍历 `0 <= j <= capacity`，计算 `dp[i][j]` 的值：
1. 如果 `j < volume[i - 1]`，说明背包装不进物品 `i`，此时有 `dp[i][j] = dp[i−1][j]`；
2. 如果 `j >= volume[i - 1]`，说明背包可以装入物品 `i`，此时求**最大价值**就存在两个方案：
   - 不放物品 `i`，问题转变为背包容量为 `j` 时，从前 i - 1 个物品中选择可以得到的最大价值，即 `dp[i - 1][j]`。
   - 放入物品 `i`，背包容量变小了，问题转变为背包容量为 `j - volume[i - 1]` 时，从前 i 个物品中选择可以得到的最大价值。可以重复选择物品 `i` 就是其区别于0-1背包问题的地方。因为物品 `i` 本身存在价值，所以最大价值为 `dp[i][j - volume[i - 1]] + value[i - 1]`。

最后的 `dp[i][j]`，应该是这两个方案下的最大值，故状态转移方程如下：

$$dp[i][j]= \left\lbrace\begin{array}{ll}
dp[i - 1][j], & j < volume[i - 1] \\
max(dp[i - 1][j],\ dp[i][j - volume[i - 1]] + value[i - 1]), & j \geq volume[i - 1]
\end{array}\right.$$

```cpp
int KnapsackProblem(vector<int>& volume, vector<int>& value, int capacity)
{
    int m = volume.size();
    vector<vector<int>> dp(m + 1, vector<int>(capacity + 1, 0));
    for (int i = 1; i <= m; ++i)    // 从前 i 个物品中选择
    {
        for (int j = 0; j <= capacity; ++j)    // j 遍历背包容量
        {
            if (j < volume[i - 1]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i][j - volume[i - 1]] + value[i - 1]);
        }
    }

    return dp[m][capacity];
}
```

### 3.2 利用滚动数组优化完全背包问题

我们同样可以使用滚动数组来优化空间复杂度，去掉 `dp` 的第一个维度。因此我们得从0开始遍历 `volume` 数组。而对于转移方程：

$$dp[i][j] = max(dp[i - 1][j], dp[i][j - volume[i - 1]] + value[i - 1])$$

我们可以发现，`dp[i][]` 不仅只和 `dp[i - 1][]` 有关，还和 `dp[i][]` 有关。如果内层循环也跟0-1背包问题一样采用**倒序遍历**，在计算 `dp[j]` 时就会发现，`dp[j − volume[i]]` 的值还没有更新过。因为 `dp[j − volume[i]]` 实际对应的是原二维数组中 `dp[i][j − volume[i - 1]]` 的值，这样得到的最大价值会比实际更小。所以完全背包问题中，对于背包的容量还是得采用**顺序遍历**。

```cpp
int KnapsackProblem(vector<int>& volume, vector<int>& value, int capacity)
{
    vector<int> dp(capacity + 1, 0);
    for (int i = 0; i < volume.size(); ++i) // 从前 i 个物品中选择
        for (int j = volume[i]; j <= capacity; ++j)    // j 遍历背包容量
            dp[j] = max(dp[j], dp[j - volume[i]] + value[i]);

    return dp[capacity];
}
```

## 4 求背包排列个数的问题

举个例子，当 `capacity = 6`，`volume[3] = value[3] = {1, 2, 3}`（物品的体积和价值相等）时，每个物品可以重复选择，求出能将装满背包的组合个数。

首先很明显答案是以下6种组合：

- `{1, 1, 1, 1, 1, 1}`
- `{1, 1, 1, 1, 2}`
- `{1, 1, 1, 3}`
- `{1, 2, 3}`
- `{2, 2, 2}`
- `{3, 3}`

利用**动态规划**和**滚动数组**可以很快解决，其中 `dp[j]` 表示在背包容量为 `j` 时能将**装满背包**的组合个数。

```cpp
int KnapsackProblem(vector<int>& volume, vector<int>& value, int capacity)
{
    vector<int> dp(capacity + 1, 0);
    for (int i = 0; i < volume.size(); ++i) // 从索引值在 [0, i] 中的物品中进行选择
        for (int j = volume[i]; j >= volume[i]; --j)    // j 遍历背包容量
            dp[j] += dp[j - volume[i]] + value[i];

    return dp[capacity];
}
```

因为物品的遍历在外层循环，`i` 固定由小到大。那么对于每一个背包容量来说，其选择物品的先后顺序，与物品在 `volume` 数组中的顺序是一致的。如果有读者感兴趣，去保存并打印循环中中符合要求的组合，其结果就是上面的6种组合。

问题就来了，如果题目改成，不同的物品选择顺序视作不同的组合，由于需要考虑选择物品的顺序，因此问题实际上变成了**求排列个数**。再按照上面的代码计算得到的结果就不对了。要解决这个问题，套用前面的背包问题模板是行不通的，更重要的是理解二维 `dp` 数组的含义和状态转移方程的推导。

对于求背包中的排列个数问题，也可分为以下几步。

### 4.1 确定 `dp[i][j]` 的含义

以下内容参考自：[组合总和Ⅳ数学推导：先构建二维dp，再优化，理解dp数组的含义十分重要](https://leetcode.cn/problems/combination-sum-iv/solutions/2663854/zu-he-zong-he-ivshu-xue-tui-dao-xian-gou-ap8y/)。

要注意，以下的排列，均是**从所有物品中进行选择**。

假设背包的最大容量为 `capacity`，每个物品的体积和价值相等且保存在数组 `volume` 中，数组大小为 `m`。我们定义二维数组 `dp`，其一维大小是 `m + 1`，二维大小是 `capacity + 1`。`dp[i][j]` 表示将**前 `i` 个物品**（`volume[0 ... i - 1]` 中）**分别**作为排列的**最后一个**时，能将背包装满的排列个数。那么 `d[m][capacity]` 就表示将前 `m` 个物品分别作为排列的最后一个时，能将背包装满的排列个数。

### 4.2 确定边界条件

当 `j = 0` 时，表示背包容量为0，能将背包装满的排列个数是1，也就是什么都不装：

$$dp[i][0] = 1\ (0 <= i <= m)$$

实际代码中只用给 `dp[0][0]` 初始化，其他边界条件在循环过程中会确定。题目不同，边界条件也会相应的发生变化。

### 4.3 确定 `dp` 的计算顺序和状态转移方程

设 `P[i][j]` 为将**第 `i` 个物品**当做排列**最后一个**时，能将背包装满的排列个数。显然，当 `i` 不同时，`P[i][j]` 所包含的排列不存在重复，则有：

$$dp[i][j] = \sum_{k = 0}^{i}P[k][j]$$

将 `P[i][j]` 分出来则有：

$$dp[i][j] = \sum_{k = 0}^{i - 1}P[k][j] + P[i][j] = dp[i - 1][j] + P[i][j]$$

对于 `P[i][j]` 包含的所有排列，其末尾物品都是 `volume[i - 1]`。去掉最后一个物品的话，剩下的排列实际上是去掉第 `i` 个物品后，所有体积和为 `j - volume[i - 1]` 的排列，即 `P[i][j] = dp[m][j - volume[i - 1]]`。之所以是 `m` 而不是 `m - 1`，因为这是完全背包问题，可以重复选择。从而可以得到状态转移方程：

$$dp[i][j] = dp[i - 1][j] + dp[m][j - volume[i - 1]]$$

那么接下来就要确定一下遍历的顺序。其实很简单，你只需要假定一个 `i` 和 `j` 的值即可（以这一节开头的举例为例）。假定当前 `i = 1`，`j = 1`，那么 `dp[1][1] = dp[0][1] + dp[3][0]`。由此可知，我们需要先计算 `d[0][1]` 和 `dp[3][0]` 的值。如果采用外层循环遍历物品，内层循环遍历背包容量，此时的 `dp[3][0]` 还没有更新过，计算的结果是不对的。所以要先遍历背包容量，当 `0 <= j <= capacity` 时，对于每一个容量值 `j`，遍历 `1 <= i <= m`，计算 `dp[i][j]` 的值。不理解的读者可以画个矩阵，然后**由左至右**，**由上至下**就能明白了。

### 4.4 求背包排列个数的 C++ 算法代码

解释一下判断逻辑：当 `j < volume[i - 1]` 时，说明背包放不下物品 `i`；或者当 `dp[i - 1][j] + dp[m][j - nums[i - 1]]` 超过 `INT_MAX` （`int` 型变量的最大值）时，我们都要令 `dp[i][j]` 继承 `dp[i - 1][j]` 的值。之所以写成减法，是因为相加的结果可能会溢出。

```cpp
int KnapsackProblem(vector<int>& volume, int capacity)
{
    int m = volume.size();
    vector<vector<int>> dp(m + 1, vector<int>(capacity + 1, 0));
    dp[0][0] = 1;
    for (int j = 0; j <= capacity; ++j) // j 遍历背包容量
    {
        for (int i = 1; i <= m; ++i)
        {
            if (j < volume[i - 1] || dp[i - 1][j] > INT_MAX - dp[m][j - volume[i - 1]])
                dp[i][j] = dp[i - 1][j];
            else dp[i][j] = dp[i - 1][j] + dp[m][j - volume[i - 1]];
        }
    }

    return dp[m][capacity];
}
```

### 4.5 利用滚动数组优化求背包排列个数的问题

由于 `dp[i][j]` 的每个元素值的计算只和同一列的上一行元素 `dp[i - 1][j]` 以及 j - volume[i - 1] 列的最后一个元素 `dp[m][j - volume[i - 1]]` 有关（即只跟列有关），因此可以使用滚动数组的方式，去掉 `dp` 的第一个维度。

`变为一维数组后，dp` 中的元素类型就可以定义为 `unsigned long long`，这样在不占用太大内存的情况下，也不需要做溢出判定了。

```cpp
int combinationSum4(vector<int>& volume, int capacity)
{
    vector<unsigned long long> dp(capacity + 1, 0);
    dp[0] = 1;
    for (int j = 0; j <= capacity; ++j)
        for (int i = 0; i < volume.size(); ++i)
            if (j >= volume[i]) dp[j] += dp[j - volume[i]];

    return dp[capacity];
}
```
