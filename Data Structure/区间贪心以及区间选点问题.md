# 1 贪心思想求解区间不相交问题

贪心思想是**求解最优化问题**的方法，它总是考虑在当前状态下的**局部最优或较优策略**，从而使全局的结果达到最优。但并非每一个问题都能通过局部最优得到全局最优，因此使用贪心思想求解最优化问题还是需要对其进行严谨的证明。

**区间不相交问题**：给出 $N$ 个**开区间** $(x，y)$，从中选择尽可能多的区间，使得这些区间**两两没有交集**。

首先考虑最简单的情况，如下图所示，如果 $I1$ 被 $I2$ 包含，那么为了满足问题要求显然应该选择更小的 $I1$ ，从而能留出更多的空间来选择其它区间。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5761a22d03c4a411c4b3ef10da7f9047.png#pic_center)

但正常情况下，需要进行选择的区间不止两个。如下图所示，将所有开区间的**左端点**按照**从大到小**的顺序进行排序（数轴上是**右大左小**）。如果**去掉区间包含**的情况，比如 $I1$ 和 $I5$，那么对于剩余所有区间的**右端点**而言，一定有 $y_1>y_2>y_3>y_4$。基于尽可能多的选择区间的前提，以及贪心的思想，我们需要优先考虑与其他区间交集较少的区间。可以观察到对于 $I1$ 来说，它的右侧一部分是没有被其他区间给包含的，也就是虚线右侧的一部分，所以我们首先应该选择 $I1$。然后将所有与 $I1$ 有重合的区间（**右端点**大于 $I1$ **左端点**的区间）给去掉即可。第一个右端点小于等于 $I1$ 左端点的区间，就会成为下一个 “$I1$” 区间。重复上述步骤即可得求解问题。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d57419161707e8c1f46684c55a79742c.png#pic_center)

# 2 区间不相交问题算法代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int maxn = 110;

struct Interval
{
    int x, y;   // 开区间的左右端点
} I[maxn];

bool cmp(Interval a, Interval b)
{
    if (a.x != b.x) return a.x > b.x;   // 先按左端点从大到小排序
    else return a.y < b.y;              // 左端点相同时，按右端点从小到大排序
}

int main()
{
    int n;  // 初始区间的个数
    cin >> n;
    for (int i = 0; i < n; ++i)
        cin >> I[i].x >> I[i].y;
    sort(I, I + n, cmp);            // 把区间排序
    int ans = 1, lastX = I[0].x;    // ans 记录不相交区间个数，lastX 保存上一个被选中区间的左端点
    for (int i = 1; i < n; ++i)
    {
        if (I[i].y <= lastX)        // 如果该区间的右端点小于等于 lastX
        {
            lastX = I[i].x;
            ++ans;                  // 不相交区间个数加1
        }
    }
    cout << ans;

    return 0;
}
```
# 3 贪心算法求解区间选点变型问题

**区间选点**：给出 N 个**闭区间** $[x, y]$，求最少需要确定多少个点，才能使得每个闭区间中都**至少存在一个点**。例如对于区间 $[1,4]$、$[2,6]$ 和 $[5,7]$ 来说，至少需要两个点，比如$3$和$5$。

区间选点可以用区间不相交同样的方法来解决。如下左图所示，可以明确知道的是 $I1$ 中的点也一定在 $I2$ 中。和右图一样，去掉区间包含的情况，由于每个闭区间中都需要一个点，因此对于左端点最大的 $I1$ 来说，取左端点 $x1$ 可以覆盖到更多其他区间。因此区间选点问题只需要将区间不相交问题中的判断条件 `I[i].y <= lastX` 改为 `I[i].y < lastX` 即可，为什么呢？

在区间不相交问题中，因为都是开区间，即使两个相邻区间的端点重合它们也没有交集。而在区间选点问题中，由于是闭区间，对于端点就不能用同样的处理方式。如下右图所示，假设 $I1$ 的左端点 $x1$ 和 $I3$ 的右端点 $y3$ 重合了，那么 `if(I[i].y <= lastX)` 为真，于是有 `lastX = x3`。在下一个 `for` 循环中，由于 `y4 > x3`，`if(I[i].y <= lastX)` 语句为假，循环结束，但此时没有点存在于 `I4` 之中，不符合问题要求。因此当相邻区间的端点重合时，存在于左边区间的点就不能用右边区间的左端点来替代，而是将左边区间的左端点作为符合条件的点，这便需要在下一个循环中实现，因此判断的条件要改为小于而不是小于等于。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4b5d7300549d01c767e552a0d2b79179.png#pic_center)

# 4 区间选点问题算法代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int maxn = 110;

struct Interval
{
    int x, y;   // 开区间的左右端点
} I[maxn];

bool cmp(Interval a, Interval b)
{
    if (a.x != b.x) return a.x > b.x;   // 先按左端点从大到小排序
    else return a.y < b.y;              // 左端点相同时，按右端点从小到大排序
}

int main()
{
    int n;  // 初始区间的个数
    cin >> n;
    for (int i = 0; i < n; ++i)
        cin >> I[i].x >> I[i].y;
    sort(I, I + n, cmp);            // 把区间排序
    int ans = 1, lastX = I[0].x;    // ans 记录不相交区间个数，lastX 保存上一个被选中区间的左端点
    for (int i = 1; i < n; ++i)
    {
        if (I[i].y < lastX)         // 如果该区间的右端点小于 lastX
        {
            lastX = I[i].x;
            ++ans;                  // 不相交区间个数加1
        }
    }
