# 背包问题（Knapsack problem）

背包问题（Knapsack Problem）在计算机科学和运筹学中是一类经典的优化问题。这个问题来源于一个简单的比喻：假设你有一个背包，这个背包有一定的**承重限制**；现在有一组物品，每个物品有自己的**重量和价值**。目标是在不超过背包承重限制的情况下，选择装入哪些物品能够使得背包中物品的总价值最大化。

通过动态规划的方法可以在有限的时间内有效地解决背包问题。动态规划通过构建一个二维数组来记录不同容量下能达到的最大价值，从而逐步求解出最终答案。此外，也可以使用启发式算法或近似算法来处理更大规模的问题，以获得接近最优解的结果。

在本文中仅介绍通过动态规划的解决0-1背包问题的方法。

## 0-1背包问题

假设背包的最大承重为 `capacity`，而每个物品的重量和价值则保存在数组或 `vector` 对象 `weigth` 和 `value` 中。现在要求你出，选择装入哪些物品能够使得背包中物品的总价值最大化。

我们用二维数组或 `vector` 对象 `dp` 来保存相关值，`dp[i][j]` 表示**背包承重为 `j` 时，从前 `i` 个物品中进行选择可以得到的最大价值**。举个例子： `d[2][3] = 5` 表明背包承重为3时，从前3个物品中进行选择可以得到的最大价值为 5（物品的索引值从0开始，所以2对应的是第三个物品）。

由于一维表示有多少种物品，二维表示 `1 ~ capacity` 的承重值。所以在定义 `dp` 时，一维的大小应该是 `weigth` 或 `value` 的大小（用 `int` 型变量 `m` 保存），二维的大小应该是 `capacity + 1`。最后返回的 `dp[m - 1][capacity]` 表示的就是背包承重为 `capacity` 时，从前 `m` 个物品中选择可以得到的最大价值。

在计算 `dp` 前，首先需要初始化第一行作为整个计算的基础。如图所示，现在 `i = 0`，即从前 `i + 1 = 1` 个物品中进行选择。物品的重量为2，价值为5。而背包最大承重是5，所以 `j` 需要枚举 0 ~ 5 的各个承重值。由于只有一个物品，那么最大价值就是该物品的价值。所以对于所有 `j >= 2` 的 `dp[0][j]`（只有承重大于等于2时才能选择该物品），我们都将其初始化为 5。

![image](https://github.com/user-attachments/assets/4bd9b2ef-1162-45a9-b341-3ef111e340ea)

在进入双层 `for` 循环后，我们采用的是**行遍历优先**，即**外层循环**固定 `i`，表明从前 `i + 1` 个物品进行选择，**内层循环**通过 `j` 枚举承重值，计算可以得到的最大价值。

对于每一个承重值 `j`，需要先判断其和 `weight[i]` 的大小关系。如果 `j < weight[i]`，说明物品重量已经超过了背包的承重值，我们选不了该物品，只能退而求其次地选择前 `i` 个物品。因为背包承重没变，所以此时有 `dp[i][j] = dp[i - 1][j]`。

如果 `j >= weight[i]`，表明我们可以选择这个物品，就存在两个方案：

1. 如果不选择的话，背包承重仍然为 `j`，所以依然有 `dp[i][j] = dp[i - 1][j]`。
2. 如果选择的话，背包承重就变为了 `j - weight[i]`，剩余的承重量还能接着选择其它的物品。问题转化为，在背包承重为 `j - weight[i]` 时，从前 `i` 个物品中进行选择可以得到的最大价值，即 `dp[i - 1][j - weight[i]]`。因此总价值就是 `dp[i - 1][j - weight[i]] + value[i]`。

而我们的 `dp[i][j]`，应该是这两个方案下的最大值。重复上述过程，就能计算出整个 `dp` 的所有值。

```cpp
int KnapsackProblem(vector<int>& weight, vector<int>& value, int capacity)
{
    int m = weight.size();
    vector<vector<int>> dp(m, vector<int>(capacity + 1, 0));
    for (int j = weight[0]; j <= capacity; ++j)
        dp[0][j] = value[0];
    for (int i = 1; i < m; ++i) // 在前 i 个物品中进行选择
    {
        for (int j = 0; j <= capacity; ++j)    // j 枚举背包承重值
        {
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }

    return dp[m - 1][capacity];
}
```
