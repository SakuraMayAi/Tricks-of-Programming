# 背包问题（Knapsack problem）

背包问题（Knapsack Problem）在计算机科学和运筹学中是一类经典的优化问题。这个问题来源于一个简单的比喻：假设你有一个背包，这个背包有一定的**容量限制**；现在有一组物品，每个物品有自己的**体积和价值**。目标是在不超过背包容量限制的情况下，选择装入哪些物品能够使得背包中物品的总价值最大化。

通过动态规划的方法可以在有限的时间内有效地解决背包问题。动态规划通过构建一个二维数组来记录不同容量下能达到的最大价值，从而逐步求解出最终答案。此外，也可以使用启发式算法或近似算法来处理更大规模的问题，以获得接近最优解的结果。

在本文中仅介绍通过动态规划的解决0-1背包问题的方法。

## 1 0-1背包问题

我个人不喜欢用承重这个词，太拗口。我更喜欢描述成背包的**容量限制**，而每个物品都是有**体积**的，你塞了一些物品进去，剩下的物品塞不进去了。就好像出去旅游，背包大小总是有限的，那么选择放入哪些物品，才能最大化的利用这个空间，就是我们所讨论的0-1背包问题。当然具体采用什么描述都是随心而定的，也得看具体的问题进行解释。

求解0-1背包问题的步骤大致可以分为以下几步。

### 1.1 确定 `dp[i][j]` 的含义

假设背包的最大容量为 `capacity`，而每个物品的体积和价值则保存在数组或 `vector` 对象 `volume` 和 `value` 中。我们用二维数组或 `vector` 对象 `dp` 来保存相关值，那么 `dp[i][j]` 便表示**背包容量为 `j` 时，从索引值在 `[0, i]` 中的物品选择可以得到的最大价值**。举个例子： `d[2][3] = 5` 表明背包容量为3时，从索引值在 `[0, 2]` 中的物品进行选择可以得到的最大价值为5。

由于一维表示有多少种物品，二维表示 `1 ~ capacity` 的容量值。所以在定义 `dp` 时，一维的大小应该是 `volume` 或 `value` 的大小（用 `int` 型变量 `m` 保存），二维的大小应该是 `capacity + 1`。最后计算得到的 `dp[m - 1][capacity]` 表示的就是背包容量为 `capacity` 时，从索引值在 `[0, m - 1]` 中的物品选择可以得到的最大价值。

### 1.2 确定计算 `dp` 的顺序

计算 `dp` 的整个过程是**由上至下**，**由左至右**的。外层循环用 `i` 进行枚举，表明当前新添加了物品 `i`，它的体积是 `volume[i]`，价值是 `value[i]`，`i` 同时也承担着**固定物品选择区间**的作用；，内层循环通过 `j` 来枚举**不同的容量**，同时逐步递增的容量保证了当 `j = capacity` 时得到的一定是**最优解**。

### 1.3 确定 `dp[i][j]` 的递推公式

在每一次**内层循环（由左至右）** 中，因为前面的 `dp` 值都已经计算完了，所以我们首先需要考虑选择的，都是当前的物品 `i`。即扩大了物品选择的范围后，对于各个容量可以得到的最大价值的变化。 

由此可以，对于每一个容量值 `j`，需要先判断其和 `volume[i]` 的大小关系。

如果 `j < volume[i]`，说明背包装不进这个物品，只能退而求其次地选择索引值在 `[0, i - 1]` 中的物品。所以 `dp[i][j] = dp[i - 1][j]`。

如果 `j >= volume[i]`，表明我们可以选择这个物品，此时求**最大价值**就存在两个方案。

1. 不放物品 `i`：问题转变为背包容量为 `j` 时，从索引值在 `[0, i - 1]` 中的物品选择可以得到的最大价值，即 `dp[i - 1][j]`。
2. 放入物品 `i`，背包容量变小了，问题转变为背包容量为 `j - volume[i]` 时，从索引值在 `[0, i - 1]` 中的物品选择可以得到的最大价值。再加上物品 `i` 本身的价值，就可以得到 `dp[i - 1][j - volume[i]] + value[i]`。

最后的 `dp[i][j]`，应该是这两个方案下的最大值，即 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - volume[i]] + value[i])`。

### 1.4 确定 `dp` 的初始值

在确定好递推公式后，需要初始化第一行作为 `dp` 计算的基础。如图所示，现在 `i = 0`，即从索引值在 `[0, 0]` 中的物品中进行选择。物品0的体积为2，价值为5。背包最大容量是5，`j` 需要枚举 0 ~ 5 的各个容量值。由于只有一个物品，那么最大价值就是该物品的价值。因此对于所有 `j >= 2` 的 `dp[0][j]`，我们都将其初始化为5（只有容量大于等于2时才能选择该物品）。

![image](https://github.com/user-attachments/assets/4bd9b2ef-1162-45a9-b341-3ef111e340ea)


### 1.5 0-1背包问题的 C++ 算法代码

```cpp
int KnapsackProblem(vector<int>& volume, vector<int>& value, int capacity)
{
    int m = volume.size();
    vector<vector<int>> dp(m, vector<int>(capacity + 1, 0));    // 相当于定义了 dp[m][n]
    for (int j = volume[0]; j <= capacity; ++j)
        dp[0][j] = value[0];    // 初始化第一行的 dp 值
    for (int i = 1; i < m; ++i) // 在前 i + 1 个物品中进行选择
    {
        for (int j = 0; j <= capacity; ++j)    // j 枚举背包容量值
        {
            if (j < volume[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - volume[i]] + value[i]);
        }
    }

    return dp[m - 1][capacity];
}
```

## 2 利用滚动数组优化0-1背包问题

由*1.3 确定 `dp[i][j]` 的递推公式*一节中我们知道，对于每一个物品 `i` 而言，其只有**选或不选**两个方案。其实观察一下推导的过程可以发现，不管容量值 `j` 与物品体积 `volume[i]` 谁更大，只要没有选择物品 `i`，最后的结果都是 `dp[i][j] = dp[i - 1][j]`。我们将比较前后的结果统一就能得到下面的递推规律：

$$不选时：dp[i][j] = dp[i - 1][j]$$

$$选择时：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - volume[i]] + value[i])$$

反正最后都是要取最大值，如果说在计算 `dp[i][j]` 前，它的值就等于 `dp[i - 1][j]`，那么是不是就可以将这两步放在一起了？是不是就不需要将 `j` 与 `volume[i]` 进行比较了，而是直接使用递推公式？

那么什么情况下能满足，`dp[i][j]` 的初值就是 `dp[i - 1][j]` 呢？很多读者想到了拷贝，但那样太麻烦了，每一次循环都得拷贝一次 `d[i - 1][j]` 的值给 `dp[i][j]`，还不如进行比较呢。我们不妨去掉 `dp` 物品种类的维度 `i`，只保留容量维度。没有了 `i` ，当前的 `dp[j]` 不就正好是上一次外层循环的 `dp[j]` 吗？

读者不要产生误解，我们的循环仍然是**双层循环**，只不过是将物品这一维抽取了出来。由于没有了一维 `i`，我们可以直接将两个公式合二为一，变成：

$$dp[j] = max(dp[j], dp[j - volume[i]] + value[i])$$

但是要注意的，改成一维后，`dp[j]` 含义就变成了：背包容量为 `j` 时可以得到的最大价值，不再与物品的种类进行关联了。这样做有好有坏，好处是我们直接得到了在各个容量值下，从**所有物品**中选择可以得到的**最大价值**；坏处是损失了从**部分物品**中选择可以得到的最大价值的数据。

还有一点需要注意，将 `dp` 改为一维后，我们需要**倒序枚举**各个容量值。因为如果还采用顺序枚举，在枚举到某一个容量值 j 时，由于 `j - volume[i] < j`，所以 `dp[j - volume[i]]` 很有可能在前面的内层循环中被修改过了。在二维 `dp` 中之所以采用顺序枚举，是因为 `dp[i - 1][j - volume[i]]` 并不存在被修改的情况。

因为采用这种方法后，每经过一次外层循环，`dp` 中的值会全都更新一次（有可能值保持不变），因此得名**滚动数组**。

```cpp
int KnapsackProblem(vector<int>& volume, vector<int>& value, int capacity)
{
    vector<int> dp(capacity + 1, 0);
    for (int i = 0; i < volume.size(); ++i) // 在前 i + 1 个物品中进行选择
        for (int j = capacity; j >= volume[i]; --j)    // j 枚举背包容量值
            dp[j] = max(dp[j], dp[j - volume[i]] + value[i]);

    return dp[capacity];
}
```

## 完全背包问题

完全背包问题，就是在0-1问题的基础上，将条件“每个物品只有一个”改成“每个物品有无数个”，从而可以重复的进行选择。因此其解题思路和0-1背包问题是一样的，唯一的区别在于物品的选择。在0-1背包问题中，我们有两种方案：选择和不选择。在完全背包问题中就变成了：**选择同一个物品多次**和**不选择**。

