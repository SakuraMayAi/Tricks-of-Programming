# 背包问题（Knapsack problem）

背包问题（Knapsack Problem）在计算机科学和运筹学中是一类经典的优化问题。这个问题来源于一个简单的比喻：假设你有一个背包，这个背包有一定的**容量限制**；现在有一组物品，每个物品有自己的**体积和价值**。目标是在不超过背包容量限制的情况下，选择装入哪些物品能够使得背包中物品的总价值最大化。

通过动态规划的方法可以在有限的时间内有效地解决背包问题。动态规划通过构建**一维或者多维数组**来记录不同容量下能达到的最大价值，从而逐步求解出最终答案。此外，也可以使用启发式算法或近似算法来处理更大规模的问题，以获得接近最优解的结果。

在本文中仅介绍通过动态规划解决背包问题的算法。

## 1 0-1背包问题

我个人不喜欢用承重这个词，太拗口。我更喜欢描述成背包的**容量限制**，而每个物品都是有**体积**的，你塞了一些物品进去，剩下的物品塞不进去了。就好像出去旅游，背包大小总是有限的，那么选择放入哪些物品，才能最大化的利用这个空间，就是我们所讨论的0-1背包问题。当然具体采用什么描述都是随心而定的，也得看具体的问题进行解释。

求解0-1背包问题的步骤大致可以分为以下几步。

### 1.1 确定 `dp[i][j]` 的含义

假设背包的最大容量为 `capacity`，每个物品的体积和价值保存在数组 `volume` 和 `value` 中。我们定义二维数组 `dp`，其中 `dp[i][j]` 表示**背包容量为 `j` 时，从索引值在 `[0, i]` 中的物品（前 i 个物品）选择可以得到的最大价值**，则最终结果就是 `d[m][capacity]`。

举个例子： `d[2][3] = 5` 表明背包容量为3时，从索引值在 `[0, 2]` 中的物品进行选择可以得到的最大价值为5。

假设数组 `volume` 的长度为 `m`，则 `dp` 的一维大小就是 `m + 1`，二维大小是 `capacity + 1`。将一维的大小定义成 `volume` 或 `value` 也是可以的，这样做的好处就是减少空间复杂度。但是需要先初始化第一行，因为计算会涉及到 `dp[i - 1]`。

题目不同，`dp[i][j]` 的具体含义也会相应的发生变化。

### 1.2 确定边界条件

当没有任何物品可以选择时（即 `i = 0` 时），体积为0，价值为0，对应的最大价值也是0，因此边界条件是：

$$dp[0][j]=0\ (0 <= j <= capacity)$$

题目不同，边界条件也会相应的发生变化。

### 1.3 确定 `dp` 的计算顺序和状态转移方程

计算 `dp` 的整个过程是**由上至下**，**由左至右**的。

当 `1 <= i <= m` 时，对于数组 `volume` 中的第 `i` 个元素 `volume[i]`，遍历 `0 <= j <= capacity`，计算 `dp[i][j]` 的值：
1. 如果 `j < volume[i]`，说明背包装不进物品 `i`，此时有 `dp[i][j] = dp[i−1][j]`；
2. 如果 `j >= volume[i]`，说明背包可以装入物品 `i`，此时求**最大价值**就存在两个方案：
   - 不放物品 `i`：问题转变为背包容量为 `j` 时，从索引值在 `[0, i - 1]` 中的物品选择可以得到的最大价值，即 `dp[i - 1][j]`。
   - 放入物品 `i`，背包容量变小了，问题转变为背包容量为 `j - volume[i]` 时，从索引值在 `[0, i - 1]` 中的物品选择可以得到的最大价值。因为物品 `i` 本身存在价值，所以最大价值为 `dp[i - 1][j - volume[i]] + value[i]`。

最后的 `dp[i][j]`，应该是这两个方案下的最大值，故状态转移方程如下：

$$dp[i][j]= \left\lbrace\begin{array}{ll}
dp[i - 1][j], & j < volume[i] \\
max(dp[i - 1][j],\ dp[i - 1][j - volume[i]]), & j \geq volume[i]
\end{array}\right.$$

### 1.4 0-1背包问题的 C++ 算法代码

```cpp
int KnapsackProblem(vector<int>& volume, vector<int>& value, int capacity)
{
    int m = volume.size();
    vector<vector<int>> dp(m + 1, vector<int>(capacity + 1, 0));
    for (int i = 1; i < m; ++i) // 从索引值在 [0, i] 中的物品中进行选择
    {
        for (int j = 0; j <= capacity; ++j)    // j 遍历背包容量
        {
            if (j < volume[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - volume[i]] + value[i]);
        }
    }

    return dp[m][capacity];
}
```

## 2 利用滚动数组优化0-1背包问题

由于 `dp[i+1][]` 的每个元素值的计算只和 `dp[i][]` 的元素值有关，因此可以使用滚动数组的方式，去掉 `dp` 的第一个维度。对于转移方程：

$$dp[i][j] = dp[i - 1][j]$$

对于内层循环，在去掉第一个维度后，若仍采用顺序遍历，计算 `dp[j]` 时，`dp[j − volume[i]]` 的值已经被覆盖了。因为 `dp[j − volume[i]]` 实际对应的是原二维数组中 `dp[i - 1][j − volume[i]]` 的值，这样得到的最大价值是不对的。采用倒序遍历就可以防止这种问题的出现。需要**倒序遍历**内层循环。

读者不要产生误解，我们的循环仍然是**双层循环**，只不过是将物品这一维抽取了出来。从而状态转移方程可以改为：

$$dp[j] = max(dp[j],\ dp[j - volume[i]] + value[i])$$

但是要注意的，改成一维后，`dp[j]` 含义就变成了：背包容量为 `j` 时可以得到的最大价值，不再与物品的种类进行关联了。这样做有好有坏，好处是我们直接得到了在各个容量值下，从**所有物品**中选择可以得到的**最大价值**；坏处是损失了从**部分物品**中选择可以得到的最大价值的数据。

因为采用这种方法后，每经过一次外层循环，`dp` 中的值会全都更新一次（有可能值保持不变），因此得名**滚动数组**。

```cpp
int KnapsackProblem(vector<int>& volume, vector<int>& value, int capacity)
{
    vector<int> dp(capacity + 1, 0);
    for (int i = 0; i < volume.size(); ++i) // 在前 i + 1 个物品中进行选择
        for (int j = capacity; j >= volume[i]; --j)    // j 遍历背包容量值
            dp[j] = max(dp[j], dp[j - volume[i]] + value[i]);

    return dp[capacity];
}
```

## 完全背包问题

完全背包问题，就是在0-1问题的基础上，将条件“每个物品只有一个”改成“每个物品有无数个”，从而可以重复的进行选择。因此其解题思路和0-1背包问题是一样的，唯一的区别在于物品的选择。在0-1背包问题中，我们有两种方案：选择和不选择。在完全背包问题中就变成了：**选择同一个物品多次**和**不选择**。

