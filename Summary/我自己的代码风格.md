本文用于记录我自己钟爱的代码风格，读者无需在意，我也不知道如何设成私密。不喜勿喷。

# 1 变量：

命名基本准则：**小驼峰命名法**，且对于绝大多数类型，都需要**通过前缀进行标识**。

我个人不会强制使用前缀，在某些情况下，所有变量都加上前缀反而会影响代码的可读性。我个人只有在确实需要进行标识的时候才会使用（比如指针和字符串我就喜欢用前缀），记录下表也只是当我想要使用前缀时，有一个可以参考的标准而已。

## 1.1 变量前缀

注意事项：

- 在64位 Windows 上，`long` 和 `int` 都是**32位**；而在64位 Linux 上，`int` 是**32位**，而 `long` 是**64位**。
- 如果想确保的代码具有良好的可移植性，以避免因平台和编译器差异导致的类型大小问题，建议使用固定宽度的整数类型，如 `int32_t` 和 `int64_t`，这些类型在 `<stdint.h>` 头文件中定义。

### 1.1.1 基本数据类型

| 前缀 | 含义 | 扩展前缀 | 含义 |
| :-: | :-: | :-: | :-: |
| a | 数组 |  |  |
| c | `char` | by | `unsigned char`，即字节 byte |
| s | `short` | us | `unsigned short` |
| i | `int` | ui | `unsigned int` |
| l | `long` | ul | `unsigned long` |
| ll | `long long` | ull | `unsigned long long` |
| f | `float` | d | `double` |
| s_ | 静态变量 | g_ | 全局变量 |

对于基本数据类型，除了指针和字符串外，个人不喜欢加前缀。从而可以节省前缀为特殊的类型使用，所以我个人更喜欢下面这样：

| 前缀 | 含义 | 扩展前缀 | 含义 |
| :-: | :-: | :-: | :-: |
| p | **一级**指针 | pp | **二级**指针（pointer to pointer） |
| s | `string`，或者泛指字符串 | c | 特指 C 语言字符串，即以字符 `\0` 结尾的字符串 |

## 1.1.2 C++ STL 容器库

| 前缀 | 含义 |
| :-: | :-: |
| vec | `vector` |
| stk | `stack` |
| que | `queue` |
| dqu | `dequeue` |
| lst | `list` |
| dst | `forward_list` |
| set | `set` |
| uset | `unordered_set` |
| mset | `multiset` |
| umset | `unordered_multiset` |
| map | `map` |
| umap | `unordered_map` |
| mmap | `multimap` |
| umap | `unordered_multimap` |

2. 初始化：
   - 使用花括号进行初始化时，括号前后均加空格：`int a { 1 };`。
   - 静态成员变量的初始化规则参考：[C++ 中静态成员变量的初始化规则.md](https://github.com/SakuraMayAi/Tricks-of-Programming/blob/main/C%2B%2B/C%2B%2B%20%E4%B8%AD%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99.md)。
   - 

# 2 函数：

1. 命名
   - 基本准则：驼峰命名法。
   - 私有、受保护函数：小驼峰命名法（即第一个字母小写）。
   - 全局、公有函数：大驼峰命名法（即第一个字母大写）。

2. 类成员函数
   
   公共接口仅仅作为入口，实际实现放在内部函数中。

# 3 类

1. 命名
   - 基本准则：大驼峰命名法（即第一个字母大写）。
   - 为指向类类型的指针取别名，在类名前加上前缀 `P(pointer)`，当然我通常更习惯用 `MyClass*`，取别名主要是为了可读性：
   ```cpp
   class MyClass
   {
      ...
   };
   // 为指向 MyClass 类的指针取别名
   using PMyClass = MyClass*;
   ```
   - 为指向函数的指针取别名，在类名前加上前缀 `PF(pointer to function)`：
   ```cpp
   class MyClass
   {
      ...
      void Task();
      ...
   };
   // 为指向 MyClass 类的指针取别名
   using PFFunc = void (MyClass::*)();
   ```
   

# 3 注释：

1. 变量注释写在行后，简短说明其是什么，或者概括其作用即可。

2. 类成员按照区域进行注释：

```cpp
public:
   /*==================== 公有成员变量 ====================*/
   /*==================== 公有成员函数 ====================*/
protected:
   /*==================== 保护成员变量 ====================*/
   /*==================== 保护成员函数 ====================*/
private:
   /*==================== 私有成员变量 ====================*/
   /*==================== 私有成员函数 ====================*/
```
   
3. 函数注释：
```cpp
/**
 * @brief   函数功能概述
 * @param   参数：名字，类型、作用、会发生的变化
 * @return  返回值
 * @note    注意事项或者补充
 *
 * @author  作者
 * @date    函数创建日期
 */
```

4. 代码块注释：
```cpp
/**
 * comment
 */
```

5. 单行**长注释**写在上方，**短注释**写在行后，比较接近的几行段注释对齐。

单行长注释

```cpp
/********** comment **********/
```

6. `if` 处为对应 `true` 情况的注释（或者说执行判断体代码需要满足的条件）。

7. 常用注释标签及其含义

| 注释标签 | 含义 |
| :-: | :-: |
| *TODO* | 待完成的任务或功能 |
| *FIXME* | 存在问题或 BUG 需要修复 |
| *INFO* | 相关信息 |
| *TAG* | 标记 |
| *BUG* | 存在 BUG |
| *REVIEW* | 需要复审 |
| *HACK* 或 *HACKER* | 临时的解决方案，需要进一步改进 |
| *DEPRECATED* | 已弃用、或将来可能会被移除 |
| *NOTE* 或 *NOTICE* | 说明、提示等重要信息 |
| *UNDONE* 或 *WIP(Work In Progress)* | 代码尚未完成 |
| *OPTIMIZE* 或 *PERFORMANCE* | 影响性能，需要优化 |

# 4 判断：

1. 对于**指针判空**和**布尔值判** `false`，都有其简洁的写法：
   
   - 指针为空：`if (p == nullptr)`，简洁写法为 `if (!p)`。
   - 布尔值为0：`if (b == false)`，简洁写法为 `if (!b)`。
  
# 5 其他：

1. 所有的花括号，分别占一层。
