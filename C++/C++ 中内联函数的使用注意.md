对于内联的函数，编译器会在**编译期**，在使用函数的地方**直接展开**函数的定义，换句话说就是直接将内联函数的代码写进去，而不是像普通函数一样通过链接器把**函数的地址**链接上。因为内联函数的调用不涉及到**函数的 call**，不会产生函数的调用跳转（无栈帧消耗），因此也就不需要链接器参与工作，就更不会去**其他编译单元**查找函数的定义。因此编译器在编译内联函数时，必须在**本编译单元**就能找到其完整定义，找不到就会报错。

总结如下：

1. 如果将**函数的实现**放在**头文件**中，那么每一个包含该头文件的 cpp 文件都将得到一份关于该函数的定义，那么链接器会报函数**重定义错误**。
2. 如果将**函数的实现**放在**头文件**中，并且用 `inline` 修饰，那么每一个包含该头文件的 `.cpp` 文件**都会得到**一份关于该函数的定义，并且链接器不会报错。
3. 如果将**函数的实现**放在 `.cpp` **文件**中，并且用 `inline` 修饰，那么该函数可以被链接到其他编译单元中。
4. 如果将**函数的实现**放在 `.cpp` **文件**中，并且用 `inline` 修饰, 那么该函数对其他编译单元不可见（类似 `static` 的效果），也就是说其他 `.cpp` 文件不能链接该函数。
