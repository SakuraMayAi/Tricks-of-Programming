# `const` 定义常量的特点：

**类型安全**：​`const`​ 定义的常量具有**明确的类型**，可以进行类型检查。这有助于避免类型相关的错误。
**作用域限制**：​`const`​ 定义的常量有**特定的作用域**，通常是在它被声明的块中。这有助于避免命名冲突，并增加了代码的可维护性。
**调试友好**：​`const`​ 定义的常量在调试过程中可以被看到，因为它们是符号名称。
**内存分配**：`​const`​ 常量通常会分配存储空间（尽管编译器可能会优化），可以取地址。

# `define` 定义常量的特点：

- **预处理器指令**: `#define` 是一个预处理器指令，用于在**编译之前**进行文本替换。它不进行**类型检查**，也**没有数据类型**。
- **全局替换**：`#define` 创建的宏在它被定义后的**所有地方**有效，直到被 `#undef` 指令取消或文件结束（即便在函数体内定义了宏，也会在整个文件中生效）。
- **不占用存储空间**：宏通常**不分配存储空间**，因为它们在编译前就被替换成相应的值或表达式。
- **可能导致意外的行为**：由于文本替换的方式，`#define` 宏可能导致一些意外的行为，尤其是在复杂的表达式中。

# 区别

## 主要区别

- **类型安全**：​`const`​ 比 `​#define`​ 提供更好的**类型安全**。
- **作用域控制**：`​const`​ 变量有特定的作用域，而 `​#define`​ 没有作用域概念，它是全局替换。
- **调试**：​`const`​ 常量在调试时更容易追踪。
- **内存分配**：​`const`​ 可能会占用存储空间，而 ​`#define`​ 不会。
- **作用阶段不同**：`const` 会减少编译时间，但是程序运行更慢，因为需要开辟内存空间保存变量（但是现代编译器通常能够对 `​const`​ 常量进行优化，尤其是在它们**没有被取地址时**）；`#define` 会增加编译时间（预编译 + 真正编译），但是程序运行更快，因为宏展开后可以直接运行。

## 特殊场景一

假设你打算用一个头文件来定义所有全局常量，并且采用 `const` 进行定义。那么所有包含该头文件的文件，都会出现 "**multiple symbol definition**" 的报错，也就是**符号重定义**。此时要么改用 `#define` 的定义方式，要么为每一个全局常量加上 `extern` 关键字进行声明。

## 特殊场景二

在某些情况下，编译器对 `#define` 的优化更好，比如如下代码：

```cpp
#define A 1
···
int a = a * A;
```

当 `A` 被定义为1时，在编译期间 `A` 就被替换为1了，在链接期间编译器就可以直接去掉这个乘法运算，因为它知道 `a * 1 = a`。但如果 `A` 是一个 `const` 定义的常量，编译器就会必须生成相应的代码来获得 `A` 的值，然后进行乘法运算，因为 `A` 的值在链接期间之前都是未知的，且在多个源代码文件中使用该 `const` 常量时需要加上 `extern` 关键字。


# 如何选择
我们通常使用 `const` 定义一个具有**特定类型**的不变值，并且这个值只在某个**特定区域**（比如一个函数或类中）有效。`const` 保证了类型安全，让代码更容易理解和维护。例如，你想在一个函数中定义一个不会改变的整数和浮点数：

```cpp
const int maxSize = 100;
const double pi = 3.1415926;
```

我们通常使用 `#define` 定义一个**全局常量**，或者创建一个**宏**（比如一个简单的代码片段）。`#define` 是在编译之前进行文本替换，且不受作用域的限制。在这种情况下，类型不是主要关注点。

```cpp
#define PI 3.1415926
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

#### 本文可转载，转载请注明出处：[SakuraMayAi：C++ 中 #define 和 const 的区别](https://github.com/SakuraMayAi/Tricks-of-Programming/blob/main/C%2B%2B/C%2B%2B%20%E4%B8%AD%20%23define%20%E5%92%8C%20const%20%E7%9A%84%E5%8C%BA%E5%88%AB)。
