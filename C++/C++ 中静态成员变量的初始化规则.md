# C++ 的数据类型

我们都知道，`C++` 存在着**基本数据类型**，其中主要分为**整型**和**浮点类型**，如下图所示（`char` 和 `boolean` 类型都划归为整型）：

![image](https://github.com/user-attachments/assets/493b92aa-6bee-46ff-8882-4d195efa08a2)

![image](https://github.com/user-attachments/assets/3a85ce49-a580-42cf-af46-99826da4bd32)

图片截取自 [cppreference.com: Fundamental types](https://en.cppreference.com/w/cpp/language/types)。

而 C++ 中如 `std::string`、`std::vector` 等都不是基本数据数据类型，其本质是**类类型**。

# 静态成员变量的初始化遵循 ODR

一般来说，静态成员变量只能在类中进行**声明**，在类外（通常是头文件对应的实现文件）进行**定义（初始化）**。如果静态成员变量在类中进行定义，那么每一个包含该头文件的文件，都会有一个该静态成员变量的定义。在**链接阶段**，由于在多个源文件中都出现了同一个变量的定义，这违反了 $ODR(One definition Rule)$，就会出现链接错误。

所以对于静态成员变量，我们通常在类中声明，在类外初始化，如下代码所示：

```cpp
class A { static int a; }; // 声明时使用关键字 static
int A::a = 1;              // 定义时不使用
```

# 例外情况

但是在某些情况下，我们确实可以在类中初始化静态成员变量。

## 情况一

在 **C++11 以前**，静态成员变量只能在类中声明，类外初始化。

在 **C++11 以后**，如果静态成员变量是**基本数据类型**，且它是一个**常量**或者**常量表达式**（严格来说，常量也属于常量表达式的范畴），即用 `const` 或者 `constexpr` 进行修饰了，那么它就可以在类中初始化。如下代码所示：

```cpp
class A 
{
    static const int a = 1;     // 常量
    static constexpr int a = 1; // 常量表达式
};
```

关于常量和常量表达式的概念，可以参考文章：[]。

## 情况二：

在 **C++17 以后**，如果静态成员变量是**基本数据类型**，且它使用了 `inline` 关键字进行修饰，那么它也可以在类中初始化，如下代码所示：

```cpp
class A  { static inline int a = 1; };
```

# 非基本数据类型不能在类中初始化

如果静态成员变量是非基本数据类型，那么不论是哪一代的 C++，它都必须**在类外初始化**。原因如下：

1. **存储和初始化**：静态成员变量在类的**所有实例（对象）之间共享**，它们在程序启动时（通常是全局初始化阶段）就被初始化。对于非基本数据类型的静态成员变量（如 `std::vector`，`std::string` 等），其初始化过程涉及**构造函数调用**、**动态内存分配**和以及**资源管理**，这些操作需要在程序启动时集中管理，以确保资源的正确分配和释放。

2. **编译单元分离**：C++ 的编译模型要求每个翻译单元（$translation unit$，即 `.cpp` 文件）独立编译。而类定义通常位于头文件中，而类的实现位于源文件中。如果在类定义中直接初始化非基本数据类型的静态成员变量，会导致多个翻译单元中出现重复的初始化代码，违反了 $One Definition Rule (ODR)$。
