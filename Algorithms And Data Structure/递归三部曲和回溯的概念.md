# 递归三部曲

递归的本质是不断地**调用自身**。它适用于能将整个问题拆分成数个相同子问题的场景。设计一个递归，需要确定好下面的三个步骤：

1. **确定递归函数的参数和返回值**

- 参数：哪些参数需要在递归中传递？是引用传递（或者说指针传递）还是值传递？区别在于，引用传递的参数被修改，会在后续所有的递归中生效（哪怕回到上一层递归）；而值传递的参数，在回到上一层就就恢复了（也即所谓的回溯）。
- 返回值：**返回值需要根据递归逻辑来具体确定**。如果每一层递归就可以单独处理一件事务，那就不需要返回值；但如果它需要来自下一层递归的信息，才能进行下一步操作，就需要返回值。

2. **确定递归边界**

- 在什么条件下，递归需要返回？一般根据题目的要求进行判定。

3. **确定单层递归的逻辑**

- 确定每一层递归的具体操作。

# 回溯的本质是递归

首先解释一下什么是回溯，假设现在有一个问题，“要求从 `[1, n]` 这个区间中选出 `k(k <= n)` 个数，问总共有几种组合”。

这种题型的本质是**穷举**，即找出所有符合要求的情况。从 `n` 个数中选择 `k` 个数，在暴力解法下，就是设置 `k` 层嵌套循环，**每层循环选择一个数**。但是当 `k` 很大时，总不能老老实实写那么多层循环吧？所以可以将该过程抽象成递归。一层递归包含一层循环，**从而每一层递归选择一个数**，且该数必须是**其它层没选过的**。

我们假设每个数字都**只有一份**，在某一层递归中选了一个数，在其它层递归就不能再选这个数了。

如果在第一层递归中选了1，在第二层递归中选了2，我们知道递归都是要返回的。当我们回到第一层递归想选2时，岂不是就没得选了，那不就等于只有一种情况了？这很明显是错的。我们的初衷是：当前层递归还存在时，它选择的数字不能再被其**下层递归**选择，当它执行完操作返回到上一层递归后，这个数字它还得还回去，以供上层递归选择，只有这样才能穷举完所有的情况。所以解决办法是，从当前层递归返回到上一层递归时，需要**将状态还原**。在这样的场景下，就是将选择的数字还回去，因此我们把类似于这样的一个过程称为**回溯**。

由上面的例子可以看出，回溯的本质是递归，回溯不过是特殊的递归。我们如何设计递归，就可以如何设计回溯，只是需要加上**状态还原**这一过程。回溯的**整个过程**可以看成一个**树型结构**，每一层递归会有很多个子集合，**子集合的个数**就是这一层的是宽度；而递归的层数是树的深度，越深，**子集合就越小**。那么从**树的根节点（初始递归）** 到 **树的叶节点（递归边界）** 的路径，就可以看做一次完整的递归过程。

那么设计一个回溯的基本过程就是：
1. 应用递归三部曲，确定好整体的递归过程。
2. 剪枝，降低时间复杂度。
