# 1 子序列的概念

本文将介绍几种与子序列有关的典型问题。首先就需要了解什么是子序列。

给定一个序列 $a$，删除（或不删除）序列中的某些元素，且不改变其余元素的顺序而到的序列，我们称为 $a$ 的**子序列**。序列 $a$ 既可以是数组，也可以是字符串、集合等包含多个同类型元素的对象。

我会把每一个问题都具体化，并将序列 $a$ 解释成一个具体的类型，从而能使读者更好的理解。但不管 $a$ 是什么类型的序列，解答问题的思路和方法都是一样的。

# 1 子序列是否存在问题

</details>
<summary>点击展开内容</summary>

## 1.1 问题概述

该问题可以简述为：给定字符串 $s$ 和 $t$ ，判断 $s$ 是否为 $t$ 的**子序列**。

## 1.2 解法一：贪心 + 双指针法

### 1.2.1 匹配过程

定义两个指针 $i$ 和 $j$，分别指向字符串 $s$ 和 $t$ 的首字符。遍历两个字符串，并对 $s[i]$ 和 $t[j]$ 进行匹配。如果匹配成功，则 $i$ 和 $j$ 同时向后移，否则只有 $j$ 向后移。如果最终 $i$ 移动到了 $s$ 的末尾，说明 $s$ 中所有字符都匹配成功了，即表明 $s$ 是 $t$ 的子序列。

有一点要注意，对于 $s[i]$，在 $t$ 中可能不止一个位置可以匹配，那究竟是匹配哪一个呢？从贪心的策略来上，我们选择匹配**先出现的那个字符**。

假如 $s[i]$ 在 $t$ 中出现了两次，一个位置在 $j_1$，另一个在 $j_2$，且 $j_1 < j_2$。那么匹配 $t[j_1]$ 是更优的选择。因为在 $t[j_2]$ 后面出现的字符，同时也在 $t[j_1]$ 的后面；而先匹配 $t[j_1]$ 的话，在 $t[j_1]$ 和 $t[j_2]$ 之间就有更多的字符可以进行匹配，增大了匹配成功的概率。

### 1.2.2 C++ 代码

```cpp
bool IsSubsequence(const string& s, const string& t)
{
    int i = 0;
    for (int j = 0; j < t.size(); ++j)
        if (s[i] == t[j]) ++i;

    return i == s.size();
}
```

## 1.3 解法二：通过动态规划建立哈希表

问题升级一下：假如有大量输入的 $s$，称作 $s1$, $s2$, ... , $sk$ 其中 $k >= 10$ 亿，你需要依次检查它们是否为 $t$ 的子序列。在这种情况下，还采用解法一肯定会超时。不妨通过动态规划的方法，建立一个哈希表，再通过哈希表去匹配 `s` 中的每一个字符，速度就会快很多了。

### 1.2.2 确定 $dp[i][j]$ 的含义

这种类似于对同一个主串做很多次匹配的问题，可以像 $KMP$ 算法一样，先用一些时间将主串中的信息建立成一个哈希表，就可以快速的进行匹配。在这里，我们姑且将字符串 $t$ 称作**主串**。

假设主串 $t$ 的长度为 $n$。定义二维数组 $dp[n + 1][26]$，$dp[i][j]$ 表示主串 $t$ 中，从位置 $i$ 开始（包括 $i$ 在内）往后字符 $j$ **第一次出现**的位置。计算完 $dp$ 后，就能得到 $t$ 中从**每一个位置**开始往后**所有字符**第一次出现的位置。数组 $dp$ 也就是我们所说的哈希表。

由于需要记录后面的字符第一次出现的次数，所以需要采用**倒序遍历**。

### 1.2.3 确定边界条件

当 $i = n - 1$，除了位置 $n - 1$，再往后就没有任何字符了，无法继续匹配。因此可以令所有的 $dp[n][j] = n(0 \leq j < 26)$，这样就能正常匹配 $dp[n - 1][j]$。且当 $dp[i][j] = n$ 时，表明从 $i$ 开始往后不存在字符 $j$ 了，匹配结束。

### 1.2.4 推导 $dp[i][j]$

遍历主串 $t$，$0 \leq i \leq n - 1$：
- 若 $t[i]$ 处的字符就是 $j$，则 $dp[i][j] = i$。
- 若 $t[i]$ 处的字符不是 $j$，则从位置 $i$ 开始往后字符 $j$ 第一次出现的位置，等同于从位置 $i + 1$ 开始往后字符 $j$ 第一次出现的位置，所以 $dp[i][j] = dp[i + 1][j]$。

综上有：

$$
f[i][j]=\left\lbrace
\begin{array}{ll}
i, & t[i]=j \\
f[i+1][j], & t[i] \neq j
\end{array}\right.
$$

### 1.2.5 匹配过程

在循环中，定义两个指针 $i$ 和 $j$ 分别指向字符串 $t$ 和 $s$ 的首字符，$j$ 遍历字符串 $s$，$0 \leq j < s.size()$。

若 $d[i][s[j] - 'a'] = n$，说明往后没有字符可以匹配了，从而 $s$ 不是 $t$ 的子串，返回 $false$；若 $d[i][s[j] - 'a'] \neq n$，说明该处的字符与 $s[j]$ 匹配，则 $i$ 要跳转到该处的**下一个位置**，与 $s$ 的下一个位置（即 $j + 1$）进行匹配。

由于除了 $n$ 之外，$dp[i][j]$ 的最大值就是 $n - 1$，所以不用担心 $i = dp[i][j]$ 会出现越界的问题。循环能正常结束就说明字符串 $s$ 中的每一个字符都匹配成功了，返回 $true$。

### 1.2.6 C++ 算法代码

```cpp
bool IsSubsequence(const string& s, const string& t)
{
    if (s.size() > t.size()) return false;  // s 比 t 更长，就不可能是 t 的子序列

    int n = t.size();
    vector<vector<int>> dp(n + 1, vector<int>(26, 0));
    for (auto& i : dp[n]) i = n;    // 初始化边界条件

    for (int i = n - 1; i >= 0; --i)
        for (int j = 0; j < 26; ++j)
            dp[i][j] = (t[i] == j + 'a') ? i : dp[i + 1][j];

    for (int i = 0, j = 0; j < s.size(); ++j)
    {
        if (dp[i][s[j] - 'a'] == n) // 到达主串末尾
            return false;
        i = dp[i][s[j] - 'a'] + 1;  // i 跳转到下一个位置进行匹配
    }

    return true;
}
```

# 2 最长递增子序列问题（Longest Increasing Subsequence，LIS）

该问题可以简述为：找到序列 $a$ 中的**最长的递增**子序列的长度。

首先要明确一个概念，最长递增子序列**不一定唯一**，比如 ${1,0,7,4}$ 就有 ${1,7}$、${1,4}$ 和 ${0, 4}$ 三个最长递增子序列。与此同时，哪怕子序列 $nums[0...m - 1]$ 和 $nums[0...m]$ 只差一个元素，所得到的最长递增子序列也不一定相同。

考虑一个简单的贪心，如果我们要使递增子序列**尽可能的长**，那我们就需要让序列递增得**尽可能的慢**。因此我们希望每次在递增子序列最后加上的那个数尽可能的小。

假设主序列为数组 nums。我们用 $S_i$ 表示**长度为** $i$ 的**任意递增子序列**，$S_i[i]$ 表示子序列中的**第 $i$ 个元素**（最后一个）；维护一个数组 $p$， $p[i]$ 表示所有长度为 $i$ 的递增子序列**末尾元素中的最小值**，易知 $S_i[i] \ge p[i] > S_i[i - 1]$。

首先，数组 $p$ 一定是递增的，证明如下：

1. 证明一：

假设数组 $p$ 不递增，则存在 $i > j$，使得 $p[i] < p[j]$。对于递增子序列 $S_i$，我们从末尾删除 $i - j$ 个元素，序列长度变为 $i - (i - j) = j$。设剩余的递增序列为 $S_j'$，其最后一个元素为 $x$，则有 $x < S_i[i - 1] < p[i] < p[j]$。此时 $S_j'$ 也是一个长度为 $j$ 的递增子序列，但末尾元素比 $p[j]$ 小，这与 $p[j]$ 的定义相矛盾。所以数组 $p$ 是递增的。

2. 证明二：

假设 $p[i]$ 是递增子序列 $S_i$ 的末尾元素，则有 $p[i] = S_i[i]$。由前面可知 $S_i[i - 1] \ge p[i - 1]$，所以有 $p[i] = S_i[i] > S_i[i - 1] \ge p[i]$，即 $p[i] > p[i]$。因此，数组 $p$ 是递增的。

定义 $len$ 保存当前最长递增子序列的长度，遍历数组 $nums$ 中的每个元素，$1 < i < nums.size()$，$p[len]$ 表示数组 $p$ 的末尾元素。
- 如果 $nums[i]$ > $p[len]$，说明遇到了一个更长的递增序列，则把 $nums[i]$ 加入到数组 $p$，并更新 $len$；
- 如果 $nums[i] \leq p[len]$，说明其有可能是比某个递增子序列末尾元素更小的元素。在数组 $p$ 中进行**二分查找**，找到第一个比 $nums[i]$ 小的数 $p[k]$，并更新 $p[k + 1] = nums[i]$。

原因如下：

如果 $nums[i] < p[len]$，且数组 $p$ 中存在 $p[k] < nums[i] \le p[k + 1]$。那么说明以 $p[k + 1]$ 为末尾元素，长度为 $k + 1$ 的递增子序列，遇到了一个更小的末尾元素 $nums[i]$，所以需要更新 $p[k + 1]$ 为 $nums[i]$。

要注意的是，最终的数组 $p$，维护的并不一定是最长递增子序列。

```cpp
int GetLIS(const vector<int>& nums)
{
    int len = 1, n = nums.size();
    vector<int> p(n + 1, 1);
    p[len] = nums[0];
    for (int i = 1; i < n; ++i)
    {
        if (nums[i] > p[len])
            p[++len] = nums[i];
        else    // 二分查找
        {
            int l = 1, r = len, k = 0;  // 找不到比 nums[i] 小的数时，就更新 p[1]
            while (l \leq r)
            {
                int mid = (l + r) >> 1;
                if (p[mid] < nums[i])
                {
                    k = mid;
                    l = mid + 1;
                }
                else r = mid - 1;
            }
            p[k + 1] = nums[i];
        }
    }

    return len;
}
```

# 最长连续递增子序列问题

# 最长公共子序列问题

# 最长连续公共子序列问题

# 子序列个数问题
