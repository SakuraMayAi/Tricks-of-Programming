*最长递增子序列（Longest Increasing Subsequence，LIS）*，该问题可以简述为：在不修改元素相对顺序的情况下，找到一个**最长的递增子序列**。

首先要明确一个概念，最长递增子序列**不一定唯一**，比如 `{1,0,7,4}` 就有 `{1,7}`、`{1,4}` 和 `{0, 4}` 三个最长递增子序列。与此同时，哪怕子序列 `nums[0...m - 1]` 和 `nums[0...m]` 只差一个元素，所得到的最长递增子序列也不一定相同。

考虑一个简单的贪心，如果我们要使递增子序列**尽可能的长**，那我们就需要让序列递增得**尽可能的慢**。因此我们希望每次在递增子序列最后加上的那个数尽可能的小。

假设主序列为数组 nums。我们用 $S_i$ 表示**长度为** $i$ 的**任意递增子序列**，$S_i[i]$ 表示子序列中的**第 $i$ 个元素**（最后一个）；维护一个数组 $p$， $p[i]$ 表示所有长度为 $i$ 的递增子序列**末尾元素中的最小值**，易知 $S_i[i] \ge p[i] > S_i[i - 1]$。

首先，数组 $p$ 一定是递增的，证明如下：

1. 证明一：

假设数组 $p$ 不递增，则存在 $i > j$，使得 $p[i] < p[j]$。对于递增子序列 $S_i$，我们从末尾删除 $i - j$ 个元素，序列长度变为 $i - (i - j) = j$。设剩余的递增序列为 $S_j'$，其最后一个元素为 $x$，则有 $x < S_i[i - 1] < p[i] < p[j]$。此时 $S_j'$ 也是一个长度为 $j$ 的递增子序列，但末尾元素比 $p[j]$ 小，这与 $p[j]$ 的定义相矛盾。所以数组 $p$ 是递增的。

2. 证明二：

假设 $p[i]$ 是递增子序列 $S_i$ 的末尾元素，则有 $p[i] = S_i[i]$。由前面可知 $S_i[i - 1] \ge p[i - 1]$，所以有 $p[i] = S_i[i] > S_i[i - 1] \ge p[i]$，即 $p[i] > p[i]$。因此，数组 $p$ 是递增的。

定义 `len` 保存当前最长递增子序列的长度，遍历数组 `nums` 中的每个元素，`1 < i < nums.size()`，`p[len]` 表示数组 `p` 的末尾元素。
- 如果 `nums[i]` > `p[len]`，说明遇到了一个更长的递增序列，则把 `nums[i]` 加入到数组 `p`，并更新 `len`；
- 如果 `nums[i] <= p[len]`，说明其有可能是比某个递增子序列末尾元素更小的元素。在数组 `p` 中进行**二分查找**，找到第一个比 `nums[i]` 小的数 `p[k]`，并更新 `p[k + 1] = nums[i]`。

原因如下：

如果 $nums[i] < p[len]$，且数组 $p$ 中存在 $p[k] < nums[i] \le p[k + 1]$。那么说明以 $p[k + 1]$ 为末尾元素，长度为 $k + 1$ 的递增子序列，遇到了一个更小的末尾元素 $nums[i]$，所以需要更新 $p[k + 1]$ 为 $nums[i]$。

要注意的是，最终的数组 $p$，维护的并不一定是最长递增子序列。

```cpp
int GetLIS(const vector<int>& nums)
{
    int len = 1, n = nums.size();
    vector<int> p(n + 1, 1);
    p[len] = nums[0];
    for (int i = 1; i < n; ++i)
    {
        if (nums[i] > p[len])
            p[++len] = nums[i];
        else    // 二分查找
        {
            int l = 1, r = len, k = 0;  // 找不到比 nums[i] 小的数时，就更新 p[1]
            while (l <= r)
            {
                int mid = (l + r) >> 1;
                if (p[mid] < nums[i])
                {
                    k = mid;
                    l = mid + 1;
                }
                else r = mid - 1;
            }
            p[k + 1] = nums[i];
        }
    }

    return len;
}
```
