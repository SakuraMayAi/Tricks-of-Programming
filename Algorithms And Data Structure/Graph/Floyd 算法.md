# *Floyd* 算法

*Floyd* 算法常用于解决**多源最短路问题**。我们通常将路径的起点称为**源点**，将路径另一端的节点称为**终点**。与此同时，我们可以将**边的权值**称为**两个节点之间的距离**。如果从源点到终点之间至少存在一条**最短路径**，那么我们就将最短路径上**所有边的权值之和**称作**最短距离**。*Floyd* 算法的适用范围很广泛，它既适用于单向图也适用于双向图，而且边的权值既可以为正也可以为负，而且 *Floyd* 算法可以用于求解图中**任意两个节点**之间的最短距离。

*Floyd* 算法的核心在于：通过**中间节点**更新图中任意两个节点 `u` 和 `v` 的最短距离。它基于这么一个概念：假定中间节点为 `k`，如果节点 `u` 到 `k` 的最短距离加上节点 `k` 到 `v` 的最短距离，小于节点 `u` 直接到 `v` 的最短距离，说明以 `k` 为中间节点的话，两点之间的最短距离更新。因此需要将 `u` 和 `v` 的最短距离更新为前者。

由此，算法需要维护一个二维数组 `d`，来保存任意两个节点之间的最短距离。同时我们可以采用三重循环，第一层循环遍历所有的中间节点 `k`；内两层循环遍历数组 `d`，然后以 `k` 为中间节点，更新所有的 `d[u][v]`。

以上三重循环就是 *Floyd* 算法的核心部分了。在有些时候，我们可能需要打印任意两个节点的最短路径的中间节点。所以可以另外维护一个数组 `mid`，`mid[u][v]` 表示节点 `u` 和 `v` 的最短距离的中间节点。

还有一点需要注意，`graph[u][v] = MAX_DISTANCE` 中，MAX_DISTANCE 是一个宏定义，表示边的权值的**理论最大值**，因此需要根据实际情况进行定义。但是不要定义成 `int` 或 `long long` 的最大值，否则在计算 `d[u][k] + d[k][v]` 时会发生溢出导致结果出错。

```cpp
// d[u][v] 表示节点 u 到 v 的最短距离，初始化为 INT_MAX 表明不存在最短路径
vector<vector<int>> d;
// mid[u][v] 表示节点 u 和 v 的最短距离的中间节点，初始值为 v
vector<vector<int>> mid;

// 计算给定有向图中任意两点间的最短距离
// graph 为邻接矩阵，graph[u][v] = MAX_DISTANCE 表明从 u 到 v 没有边
// 有向图中的边权可以为负，而最短路径中可能存在重复经过的节点
void Floyd(const vector<vector<int>>& graph)
{
    // 节点个数
    int n = graph.size();
    // d 初始化为 gradp
    d = graph;
    mid.resize(n);
    for (auto& v : mid)
    {
        v.resize(n);
        // iota 函数为数组 v 从0开始递增赋值，需要头文件 <numeric>
        iota(v.begin(), v.end(), 0);
    }

    for (int k = 0; k < n; ++k) // 遍历所有中间节点
    {
        // 遍历邻接矩阵，以 k 为中间节点，更新每一个 d[u][v]
        for (int u = 0; u < n; ++u)
        {
            for (int v = 0; v < n; ++v)
            {
                // 节点 u 到 k 的最短距离 + 节点 k 到 v 的最短距离 < u 到 v 的最短距离
                if (d[u][k] + d[k][v] < d[u][v])
                {
                    d[u][v] = d[u][k] + d[k][v];    // 更新节点 u 到 v 的最短距离
                    mid[u][v] = k;                  // 更新中间节点
                }
            }
        }
    }
}
```

