# 前言

*Prim* 算法和 *Kruskal* 算法都是用来计算**最小生成树的权值和**或者**获取最小生成树**的算法。它们会以最小的权值和将图中所有的节点连接到一起，构成一个**最小生成树（最小连通子图）**。

# *Prim* 算法

在 *Prim* 算法中，我们将**边的权值**视作**两个节点之间的距离**。

*Prim* 算法采用贪心策略，每次都选取**距离最小生成树最近的节点**，并将其加入到最小生成树中。初始时，最小生成树中没有任何节点。算法通过一个循环来将**所有节点逐个**连接到最小生成树上，每一轮循环可以分为三个步骤：

1. 寻找距离最小生成树最近的节点 `u`；
2. 将节点 `u` 加入最小生成树，并更新最小生成树权值和；
3. 以节点 `u` 为基点，更新最小生成树与剩余节点的距离。

要注意两点：

1. 此处默认节点下标从0开始，如果你的场景不同，则需要修改相应的循环条件。
2. 此处默认最小生成树从节点0开始构造，因此在第一个循环需要保证选取节点0。如果你的场景中需要从节点 `x` 开始构造，则将 `d[0] = 0` 更改为 `d[x] = 0`。

```cpp
// 计算给定图的最小生成树的权值之和
// graph 为邻接矩阵，graph[u][v] = 0 表明从 u 到 v 没有边
// 函数返回最小生成树的权值和
int Prim(const vector<vector<int>>& graph)
{
    // 节点个数
    int n = graph.size();
    // d[u] 表示节点 u 到最小生成树的最小距离，初始化为 INT_MAX 表明其不在最小生成树中
    vector<int> d(n, INT_MAX);
    // pick[u] = false 表示节点 u 还没有选取
    vector<bool> pick(n, false);
    // 令 d[0] = 0 保证在第一次循环选取节点0
    d[0] = 0;
    int sum = 0;    // 权值和
    for (int i = 0; i < n; ++i) // 遍历所有节点
    {
        // 寻找距离最小生成树最近的节点 u
        int u = -1, mind = INT_MAX; // u 保存最近节点，mind 保存 d 中最小值
        for (int j = 0; j < n; ++j)
        {
            if (!pick[j] && d[j] < mind)
            {
                u = j;          // 更新节点
                mind = d[j];    // 更新最小值
            }
        }

        // 将节点 u 加入最小生成树，并更新最小生成树权值和
        // u 仍为-1，说明由源点到节点 u 没有路径
        // 最小生成树无法构造，返回-1
        if (u == -1) return -1;
        pick[u] = true;
        sum += d[u];

        // 以节点 u 为基点，更新最小生成树与剩余节点的最小距离
        for (int v = 0; v < n; ++v)
        {   
            // 如果 v 没有选取，且边 (u, v) 的距离相较于之前更小
            if (!pick[v] && graph[u][v] != 0 && graph[u][v] < d[v])
                d[v] = graph[u][v];
        }
    }

    return sum;
}
```

# *Kruskal* 算法

*Kruskal* 算法同样采用贪心策略，但它是每次选取**不在最小生成树中的权值最小的边**。所以需要声明一个**边结构体**来记录**每条边的信息**，传递的参数是保存所有边的信息的**边表（数组）**，边表需要根据给定的图或者输入来构造。

每次选取边时，都需要确保**连通子图不产生环**。如果我们将最小生成树中的所有节点当做一个集合，那么只有当一条边的两个端点**至少有一个不在集合中**时，它的加入才不会导致最小生成树产生环。显然，最快速的判断方法就是利用**并查集**。并查集可以快速的查找给定的两个节点是否在一个集合中。

初始时，最小生成树中没有任何边。算法先将所有的边按照权值**由小到大**进行排序，随后通过一个循环来将**部分边逐个**连接到最小生成树上，每一轮循环可以分为两个步骤：

1. 从排好序的边表中选取一个边，获取其两个端点的根节点；
2. 如果根节点不同，说明不会生成环，将边加入到最小生成树中。

要注意一点：此处默认节点下标从0开始，如果你的场景不同，则需要修改相应的循环条件。

```cpp
struct Edge
{
    int u, v, val;  // 端点，权值
};
// 按边的权值由小到大进行排序
bool cmp(Edge a, Edge b) { return a.val < b.val; }
// root[x] 表示节点 x 的根节点
vector<int> root;
// 寻找节点 x 的根节点，同时执行路径压缩
int Find(int x) { return root[x] == x ? x : root[x] = Find(root[x]); }

// 计算给定边表的最小生成树的权值之和
// edge 保存所有边的信息，n 为节点个数
// 函数返回最小生成树的权值和
int Kruskal(vector<Edge>& edge, int n)
{
    // 边条数
    int m = edge.size();
    root.resize(n, 0);
    // sum 为权值和，num 为最小生成树的边数
    int sum = 0, num = 0;
    for (int i = 0; i < n; ++i) root[i] = i;
    sort(edge.begin(), edge.begin() + m, cmp);
    for (int i = 0; i < m; ++i)     // 遍历所有的边
    {
        int ru = Find(edge[i].u);   // 获取 u 的根节点
        int rv = Find(edge[i].v);   // 获取 v 的根节点
        if (ru != rv)   // 根节点不同，说明 u 和 v 不同时在最小生成树中
        {
            root[ru] = rv;          // 将边加入到最小生成树
            sum += edge[i].val;     // 更新权值和
            if (num + 1 == n) break; // 边数等于节点数减1，结束算法
        }
    }
    // 循环结束，边数不为节点数减1，则无法构造最小生成树，返回-1
    if (num + 1 != n) return 0;

    return sum;
}
```