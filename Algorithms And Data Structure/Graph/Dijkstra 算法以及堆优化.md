# 1 朴素 *Dijkstra* 算法

感兴趣的读者可以先阅读同文件夹下的文章：[Prim 算法和 Kruskal 算法.md](./Prim%20算法和%20Kruskal%20算法.md)。*Dijkstra* 算法与 *Prim* 的核心思想是一样的。

*Dijkstra* 算法常用于解决**单源最短路问题**。我们通常将路径的起点称为**源点**，将路径另一端的节点称为**终点**。与此同时，我们可以将**边的权值**称为**两个节点之间的距离**。如果从源点到终点之间至少存在一条**最短路径**，那么我们就将最短路径上**所有边的权值之和**称作**最短距离**。*Dijkstra* 算法适用于**不存在负边权**的**单向图**。

由此，算法需要维护一个数组 `d`，来保存源点与所有节点的最短距离。循环结束后，`d[终点]` 即是我们需要的结果。为了求取 `d[终点]`，*Dijkstra* 算法采用**贪心策略**，每次都选取**距离源点最近的节点**。初始时，我们需要从源点开始构造路径。算法通过一个循环来**逐个计算与所有节点**的最短距离，每一轮循环可以分为三个步骤：

1. 寻找距离源点最近的节点 `u`；
2. 选取节点 `u`；
3. 以节点 `u` 为基点，更新源点与剩余节点的最短距离。

要注意两点：

1. 此处默认节点下标从0开始，如果你的场景不同，则需要修改相应的循环条件。
2. 为了确保从源点开始构造路径，必须在第一个循环选取源点 `start`，所以需要令 `d[start] = 0`。

```cpp
// 计算给定有向图由源点到终点的最短距离
// graph 为邻接矩阵，graph[u][v] = 0 表明从 u 到 v 没有边
// start 为源点，end 为终点
// 函数返回最短距离，若源点无法到达终点则返回-1
int Dijkstra(const vector<vector<int>>& graph, int start, int end)
{
    // 节点个数
    int n = graph.size();
    // d[u] 表示源点到节点 u 的最短距离，初始化为 INT_MAX 表明不存在最短路径
    vector<int> d(n, INT_MAX);
    // pick[u] = false 表示节点 u 还没有选取
    vector<bool> pick(n, false);
    // 令 d[start] = 0 保证在第一次循环选取源点
    d[start] = 0;
    for (int i = 0; i < n; ++i) // 遍历所有节点
    {
        // 寻找距离源点最近的节点 u
        int u = -1, mind = INT_MAX; // u 记录最近节点，mind 保存 d 中最小值
        for (int j = 0; j < n; ++j)
        {
            if (!pick[j] && d[j] < mind)
            {
                u = j;          // 更新节点
                mind = d[j];    // 更新最小值
            }
        }

        // 选取节点 u
        // u 仍为-1，说明由源点到节点 u 没有路径
        // 此时应该进入下一次循环而不是结束寻找
        if (u == -1) continue; 
        pick[u] = true;

        // 以节点 u 为基点，更新源点与剩余节点的最短距离
        for (int v = 0; v < n; ++v)
        {   
            // v 没有选取，且 (u, v) 之间有边，且源点和 v 的最短距离相较于之前更小
            if (!pick[v] && graph[u][v] != 0 && d[u] + graph[u][v] < d[v])
                d[v] = d[u] + graph[u][v];  // 更新源点到 e.to 的最短距离
        }
    }

    return d[end] == INT_MAX ? -1 : d[end];
}
```

有读者可能已经发现了，最小生成树包含图中所有的节点，所以我们可以通过 *Prim* 或 *Kruskal* 算法获取最小生成树。但是数组 `d` 维护的是从源点到每个节点的**最短路径的距离**，它并不一定是唯一的，所以通过 *Dijkstra* 算法不能获取最短路径。

*Dijkstra* 算法与 *Prim* 算法还有一个区别在于：当源点不同时，我们**不能保证源点到所有的节点都有路径**。因此在遍历节点的时候，有可能在某一轮循环中没有选取到节点。此时应该进入下一次循环，而不是直接返回。而在 *Prim* 算法中，如果某一轮循环没有选取到更近的节点，说明图本身就不能连通，也就不可能构造最小生成树，所以需要直接返回。

# 2 堆优化的 *Dijkstra* 算法

在朴素 *Dijkstra* 算法中，有两层 `for` 循环。第一层 `for` 循环保证算法能遍历到图中所有的节点；第二层 `for` 循环是在选取了节点 `u` 后，遍历所有 `u` 能到达的节点。由于采用**邻接矩阵**来保存所有边之间的距离，这就导致，当图是一个稀疏图（节点很多但边很少）时，选取节点 `u` 后，即使以 `u` 为起点可能只有一条边，我们依然需要遍历其余所有节点，算法的效率就会很变得很差。

优化的重点在于**将邻接矩阵换成邻接表**。这样就不用在选取节点后，遍历其余所有节点，而是**只遍历以该节点为起点的所有边**。在优化后 *Dijkstra* 算法中，我们不再选取**距离源点最近的节点**，而是选取**所有最短距离中最小的一个**（参见 *朴素 Dijkstra 算法* 章节中第二段中关于“最短距离”的解释）。

> 为了不那么绕口，后文中就将“最小的最短距离”称为 $min$(最短距离)。

这时就有一个新问题了。我们怎么确定谁是 $min$(最短距离)？换句话说，我们需要一个数据结构，能够实时维护源点到所有节点的最短距离。类似于 *Kruskal* 算法，既然选取的对象是边，就需要声明一个**边结构体**来记录**每条边的信息**，而传递的参数是**邻接表**，邻接表需要根据给定的图或者输入来构造。

与此同时我们需要声明一个**最短路径结构体**来记录源点到每一个节点的**最短路径信息**，包括该条最短路径的**终点**，以及**最短距离**。并通过一个优先级队列来维护所有的最短路径，最理想的就是构造一个小顶堆。小顶堆能在 $O(log_2E)$ 的时间复杂度下维护一个排序，并将最小者放在树的顶部。在每一轮循环中，我们只需要取出树的顶部节点，就可以获取 $min$(最短距离)。

整个过程和朴素 *Dijkstra* 算法几乎一样。我们获取小顶堆的顶部节点，就获取了 $min$(最短距离) ，以及该路径的终点 `dest`，也即我们**要选取的节点**。然后以该节点为基点，更新源点与剩余节点的**最短距离**。怎么更新呢？遍历以 `dest` 为起点的所有边，如果源点到 `dest` 的最短距离 + 边 `(dest, v)` 的距离 < 源点到 `v` 的最短距离，将源点到 `v` 的最短距离更新为前者，同时将这个**新的最短路径**加入到小顶堆维护。

有的读者应该意识到一点了，那就是旧的最短路径信息不是还在小顶堆中吗，会不会影响到选取？答案是不会，因为它“更长”，所以它不可能成为 $min$(最短距离)，也就不会被选取。

```cpp
// 边结构体
struct Edge
{
    int from, to, val;  // from，to 分别为边的起点和终点，val 为边的权值
};
// 最短距离结构体
struct MinDist
{
    int dest, mind; // dest 为最短路径的终点，mind 为最短路径的距离
    MinDist(int d, int m) : dest(d), mind(m) {};
};
// 比较类，用于将优先级队列构造为小顶堆
class comparsion
{
public:
    bool operator()(const MinDist& lhs, const MinDist& rhs) { return lhs.mind > rhs.mind; }
};

// 计算给定有向图由源点到终点的最短距离
// edges 为邻接表，start 为源点，end 为终点
// edges[i] 为链表，保存所有以 i 为起点的边
// 函数返回最短距离，若源点无法到达终点则返回-1
int Dijkstra(const vector<list<Edge>>& edges, int start, int end)
{
    // 节点个数
    int n = edges.size();
    // d[u] 表示源点到节点 u 的最短距离，初始化为 INT_MAX 表明不存在最短路径
    vector<int> d(n, INT_MAX);
    // pick[u] = false 表示节点 u 还没有选取
    vector<bool> pick(n, false);
    // 小顶堆维护源点到所有节点的最短路径信息，并按照最短距离排序
    priority_queue<MinDist, vector<MinDist>, comparsion> pq;
    // 令 d[start] = 0 保证在第一次循环选取源点
    d[start] = 0;
    // 源点到源点的最短距离为0
    pq.push(MinDist(start, 0));
    while (!pq.empty())
    {
        // 获取堆顶元素，即获得最短路径信息
        MinDist minDist = pq.top();
        pq.pop();

        // 选取该最短路径的终点
        int dest = minDist.dest;
        if (pick[dest]) continue;  // 已被选取，进入下一次循环
        pick[dest] = true;

        // 以 dest 为基点，更新源点与剩余节点的最短距离
        for (const Edge& e : edges[dest])   // 遍历以 dest 为起点的所有边
        {
            // 节点 e.to 没有选取，且源点到 dest 的最短距离 + 边 (dest, e.to) 的距离 < 源点到 e.to 的最短距离
            if (!pick[e.to] && d[dest] + e.val < d[e.to])  
            {
                d[e.to] = d[dest] + e.val;  // 更新源点到 e.to 的最短距离
                // 将终点为 e.to，最短距离为 d[e.to] 的新最短路径加入小顶堆维护
                pq.push(MinDist(e.to, d[e.to]));
            }
        }
    }
    
    return d[end] == INT_MAX ? -1 : d[end];
}
```
