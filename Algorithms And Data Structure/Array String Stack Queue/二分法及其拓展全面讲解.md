# 1 二分查找
## 1.1 严格递增/递减数组的二分查找

**二分查找解决的问题** ：如何在一个严格递增/递减数组（序列） `nums` 中找出给定的数 `x`。可以将二分查找理解成一个将区间不断压缩直到“夹出”待查找元素下标的过程。二分查找**只适用于有序的数组**，不能用于无序的数组。

基本过程：设查找区间为 `[left, right]`，计算其中间位置 `mid = (left + right) / 2`（向下取整），然后比较待查找元素 `nums[mid]` 与 `x` 的大小。

 - 如果 `nums[x] == x`，说明查找成功，返回 `x` 的下标，退出查找；
 - 如果 `nums[mid] > x`，说明 `x` 在 `nums[mid]` 左侧，需要往左子区间 `[left, mid - 1]` 继续查找；
 - 如果 `nums[mid] < x`，说明 `x` 在 `nums[mid]` 右侧，需要往右子区间 `[mid + 1, right]` 继续查找。

具体如下图所示：

![alt text](./img/二分法-1.png)

二分查找的高效之处在于，每一步查找都可以去除当前区间中的一半元素，因此其时间复杂度是 $O(log_2n)$。

## 1.2 严格递增数组的二分查找算法代码

```cpp
// 二分查找的过程与数组下标从0开始还是从1开始无关
// 数组 nums 为严格递增数组，x 为待查找元素
int BinarySearch(const vector<int>& nums, int x)
{
    // num.back() 返回数组末尾的元素
    // 数组为空，或者 x 在数组之外返回-1
    if (nums.size() == 0 || x < nums[0] || x > nums.back()) return -1;
    // 查找区间为 [left, right]，左闭右闭
    int left = 0, right = nums.size() - 1, mid;
    while (left <= right) // 如果 left > right 就没办法形成闭区间了
    {
        mid = (left + right) / 2;
        if (nums[mid] == x) return mid;    // 查找成功，返回下标
        else if (nums[mid] > x)
            right = mid - 1;    // 往左子区间 [left, mid - 1] 查找
        else left = mid + 1;    // 往右子区间 [mid + 1, right] 查找
    }
    
    return -1;	// 不存在元素 x，返回-1
}
```

之所以采用 `left <= right` 作为循环条件，是因为存在 `left = right` ，即两者指向同一个元素的情况：

- 如果这个元素刚好等于 `x`，那么返回的下标 `mid` 就是我们要的结果，不加等号就会导致遗漏这种情况；
- 如果它不等于 `x`，要么 `left` 变大，要么 `right` 变小，此时的 `[left, ritht]` 就构不成一个查找区间了，从而循环结束。

需要注意的是，如果 `right` 超过了其数据类型**最大值的一半**，那么当待查找元素在数组比较靠后的位置时，语句 `mid = (left + right) / 2` 有可能会溢出，改成 `mid = left + (right - left) / 2` 即可解决。

## 1.2.1 严格递减数组的二分查找算法代码

对于递减数组的二分查找算法代码，和递增时是一样的。只需要改变子区间的查找方向即可，在后文中也不在赘述。本文仅给出递增数组的二分查找算法代码，递减数组的二分查找算法代码请读着自行实现。

## 1.3 非严格递增数组的问题汇总

如果将数组 `nums` 变成一个**非严格递增（即其中的元素可能重复）** 的数组，就可以引申出六问题：

1. 求出**非严格递增**数组中**第一个等于** `x` 的元素的位置；
2. 求出**非严格递增**数组中**最后一个等于** `x` 的元素的位置。
3. 求出**非严格递增**数组中**第一个大于** `x` 的元素的位置；
4. 求出**非严格递增**数组中**第一个大于等于** `x` 的元素的位置；
5. 求出**非严格递增**数组中**最后一个大于** `x` 的元素的位置；
6. 求出**非严格递增**数组中**最后一个小于等于** `x` 的元素的位置。

接下来将讲解这四类问题如何通过二分查找去解决。

### 1.3.1 求出非严格递增数组中第一个、最后一个等于 `x` 的元素的位置

首先求第一个等于 `x` 的元素的位置。

基本过程：设查找区间为 `[left, right]`，计算其中间位置 `mid = (left + right) / 2`（向下取整），然后比较 `nums[mid]` 与待查找元素 `x` 的大小关系。

- 如果 `nums[x] == x`，需要往**左子区间** `[left, mid - 1]` 继续查找；
- 如果 `nums[mid] >= x`，说明 `x` 在 `nums[mid]` 左侧，需要往**左子区间** `[left, mid- 1]` 继续查找；
- 如果 `nums[mid] < x`，说明 `x` 在 `nums[mid]` 右侧，需要往**右子区间** `[mid + 1, right]` 继续查找。

对于 `nums[x] == x` 的解释：尽管 `nums[mid] = x`，但它不一定是第一个等于 `x` 的元素，在 `nums[mid]` 的**左侧**可能还存在 `x`，因此要前往**左子区间**继续查找。由二分查找的性质我们可以知道 `nums[mid]` 一定会在某轮循环中成为第一个等于 `x` 的元素。

#### 1.3.1.1 元素 `x` 在数组中时

这时有的读者可能就会问了，如果 `nums[mid]` 成为了第一个等于 `x` 的元素，按照循环，此时仍然会前往左子区间，那不就把 `x` 排除在查找区间之外了吗？确实是这样，尽管如此我们依然可以得到答案，解释如下：

假设 `nums[mid]` 就是第一个等于 `x` 的元素，我们标记此时的 `mid` 为 `M`。令 `right = mid - 1 = M - 1` 后，在子区间 `[left, right]` 中的元素一定**全部小于** `x`，此时的位置关系如下图左侧所示。循环继续，由于 `x` 大于该子区间内的所有元素，所以 `right` 会始终固定为 `M - 1`，而 `left` 会不断变大，直到某一轮循环后出现 `left > right` 结束循环。此时的位置关系如下图右侧所示。可以看到，即使 `x` 不在查找区间中，最后的 `left` 也一定会指向数组中的第一个 `x`。

![alt text](./img/第一个等于.png)

相应的做法可以应用到求**最后一个等于** `x` 的元素的位置。当 `nums[mid] == x` 时，令 `left = M + 1`，前往 **右子区间** `[mid + 1, right]` 继续查找，此时的位置关系如下图左侧所示。随后循环会不断地将 `right` 变小，直到 `left > right` 结束循环，此时的位置关系如下右图右侧所示（`t1 > x`）。可以看到，即使 `x` 不在查找区间中，最后的 `right` 也一定会指向数组中的最后一个 `x`。

![alt text](./img/最后一个等于.png)

#### 1.3.1.2 元素 `x` 不在数组中时

其实由这个过程可以发现，对于第一个问题而言，如果数组中不存在 `x`，算法也一定会将查找区间缩小到一个子区间 `[left, right]`：该子区间内的所有元素均**小于** `x`，而 `right` 右侧第一个元素 `y` 大于 `x`，如下图所示左侧所示；在循环结束后，`left` 也一定会指向数组元素 `y`。

![alt text](./img/第一个等于_不在数组中.png)

同理，对于第二个问题而言，如果数组中不存在 `x`，算法也一定会将查找区间缩小到一个子区间 `[left, right]`：该子区间内的所有元素均**大于** `x`，而 `left` 右侧第一个元素 `y` 大于 `x`，如下图所示左侧所示；在循环结束后，`right` 也一定会指向数组元素 `y`。

![alt text](./img/最后一个等于_不在数组中.png)

#### 1.3.1.3  求出非严格递增数组中第一个等于 `x` 的元素位置的算法代码

首先，如果在数组中找不到元素 `x` 就需要返回-1，所以在返回的 `left` 时候，需要先判断一下 `nums[left]` 是否等于 x。

其次，如果 `x` **大于数组的所有元素**，在循环结束后，`left` 就等于数组长度。此时访问 `num[left]` 会出现越界错误。所以我们将这一判断放到二分查找之前，只要 `x` 大于数组的尾元素，就说明 `x` 大于数组中所有元素，因而找不到符合要求的元素的位置，返回-1。

```cpp
// 二分查找的过程与数组下标从0开始还是从1开始无关
// 数组 nums 为非严格递增数组，x 为待查找元素
int FirstEq(const vector<int>& nums, int x)
{
    // num.back() 返回数组末尾的元素
    // 数组为空，或者 x 大于数组所有元素返回-1
    if (nums.size() == 0 || nums.back() < x) return -1;
    // 查找区间为 [left, right]，左闭右闭
    int left = 0, right = nums.size() - 1, mid;
    while (left <= right)
    {
        mid = (left + right) / 2;
        if (nums[mid] >= x)     // 注意两者区别在这里
            right = mid - 1;    // 往左子区间 [left, mid - 1] 查找
        else left = mid + 1;    // 往右子区间 [mid + 1, right] 查找
    }

    // nums[left] 不等于 x 时返回-1
    return nums[left] == x ? left : -1; // x 不存在时返回-1
}
```

#### 1.3.1.4 求出非严格递增数组中最后一个等于 `x` 的元素位置的算法代码

首先，如果在数组中找不到元素 `x` 就需要返回-1，所以在返回的 `right` 时候，需要先判断一下 `nums[right]` 是否等于 x。

其次，如果 `x` **小于数组中的所有元素**，在循环结束后，`right` 就等于-1。此时访问 `num[right]` 会出现越界错误。所以我们将这一判断放到二分查找之前，只要 `x` 小于数组的首元素，就说明 `x` 小于数组中所有元素，因而找不到符合要求的元素的位置，返回-1。

```cpp
// 二分查找的过程与数组下标从0开始还是从1开始无关
// 数组 nums 为非严格递增数组，x 为待查找元素
int LastEq(const vector<int>& nums, int x)
{
    // num.back() 返回数组末尾的元素
    // 数组为空，或者 x 小于数组所有元素返回-1
    if (nums.size() == 0 || nums[0] > x) return -1;
    // 查找区间为 [left, right]，左闭右闭
    int left = 0, right = nums.size() - 1, mid;
    while (left <= right)
    {
        mid = (left + right) / 2;
        if (nums[mid] > x)      // 注意两者区别在这里
            right = mid - 1;    // 往左子区间 [left, mid - 1] 查找
        else left = mid + 1;    // 往右子区间 [mid + 1, right] 查找
    }

    // nums[right] 不等于 x 时返回-1
    return right != -1 && nums[right] == x ? right : -1; // x 不存在时返回-1
}
```

### 1.3.2 第一个大于、最后一个小于、第一个大于等于、最后一个小于等于问题

该类型问题可分为以下几个：

1. 求出**非严格递增**数组中**第一个大于等于** `x` 的元素的位置；
2. 求出**非严格递增**数组中**最后一个小于** `x` 的元素的位置；
3. 求出**非严格递增**数组中**第一个大于** `x` 的元素的位置；
4. 求出**非严格递增**数组中**最后一个小于等于** `x` 的元素的位置；

有的读者可能会问，还有诸如“最后一个大于”、“第一个小于”等等的问题呢？其实这些问题跟二分查找是无关的，就拿“最后一个大于”举例。对于一个非严格递增数组来说，要求最后一个大于 `x` 的元素，直接从数组的末尾开始反向遍历就行了，根本用不上二分查找，所以我在这里就不将它们当做二分查找的衍生问题。

由 *1.3.2 小节* 可知，当数组中不存在 `x` 时，在循环结束后，`left` 和 `right` 的值就如下图右侧所示，我们挨个来分析。在下面这幅图的右侧可以看到，在循环结束后有 `nums[left - 1] = t2 < x < nums[left] = y`。当 `x` 在数组中时，这个 `y` 就是 `x`。所以我们可以得出以下结论：

1. `nums[left]` 是**第一个大于等于** `x` 的元素；
2. `nums[left - 1]` 是**最后一个小于** `x` 的元素。

![alt text](./img/第一个等于_不在数组中.png)

而由下面这幅图的右侧可以看到，在循环结束后有 `nums[right] = y < x < nums[right + 1] = t1`。当 `x` 在数组中时，这个 `y` 就是 `x`。所以我们可以得出以下结论：

1. `nums[right + 1]` 是**第一个大于** `x` 的元素。
2. `nums[right]` 是**最后一个小于等于** `x` 的元素。

![alt text](./img/最后一个等于_不在数组中.png)

#### 1.3.1.1 求出非严格递增数组中第一个大于等于 `x` 的元素位置的算法代码

考虑到当 `x` 大于数组中所有元素时，数组中不存在符合要求的位置，所以需要提前判断然后返回-1。

```cpp
// 二分查找的过程与数组下标从0开始还是从1开始无关
// 数组 nums 为非严格递增数组，x 为待查找元素
int FirstGe(const vector<int>& nums, int x)
{
    // num.back() 返回数组末尾的元素
    // 数组为空，或者 x 大于数组所有元素返回-1
    if (nums.size() == 0 || nums.back() < x) return -1;
    // 查找区间为 [left, right]，左闭右闭
    int left = 0, right = nums.size() - 1, mid;
    while (left <= right)
    {
        mid = (left + right) / 2;
        if (nums[mid] >= x)
            right = mid - 1;    // 往左子区间 [left, mid - 1] 查找
        else left = mid + 1;    // 往右子区间 [mid + 1, right] 查找
    }

    return left;
}
```

#### 1.3.1.2 求出非严格递增数组中最后一个小于 `x` 的元素位置的算法代码

考虑到当 `x` 小于数组中所有元素时，数组中不存在符合要求的位置，所以需要提前判断然后返回-1。

```cpp
// 二分查找的过程与数组下标从0开始还是从1开始无关
// 数组 nums 为非严格递增数组，x 为待查找元素
int LastLt(const vector<int>& nums, int x)
{
    // num.back() 返回数组末尾的元素
    // 数组为空，或者 x 小于数组所有元素返回-1
    if (nums.size() == 0 || nums[0] > x) return -1;
    // 查找区间为 [left, right]，左闭右闭
    int left = 0, right = nums.size() - 1, mid;
    while (left <= right)
    {
        mid = (left + right) / 2;
        if (nums[mid] >= x)
            right = mid - 1;    // 往左子区间 [left, mid - 1] 查找
        else left = mid + 1;    // 往右子区间 [mid + 1, right] 查找
    }

    return left - 1;
}
```

#### 1.3.1.3 求出非严格递增数组中第一个大于 `x` 的元素位置的算法代码

考虑到当 `x` 大于数组中所有元素时，数组中不存在符合要求的位置，所以需要提前判断然后返回-1。

```cpp
// 二分查找的过程与数组下标从0开始还是从1开始无关
// 数组 nums 为非严格递增数组，x 为待查找元素
int FirstGt(const vector<int>& nums, int x)
{
    // num.back() 返回数组末尾的元素
    // 数组为空，或者 x 大于数组所有元素返回-1
    if (nums.size() == 0 || nums.back() < x) return -1;
    // 查找区间为 [left, right]，左闭右闭
    int left = 0, right = nums.size() - 1, mid;
    while (left <= right)
    {
        mid = (left + right) / 2;
        if (nums[mid] > x)      // 注意两者区别在这里
            right = mid - 1;    // 往左子区间 [left, mid - 1] 查找
        else left = mid + 1;    // 往右子区间 [mid + 1, right] 查找
    }

    return right + 1;
}
```

#### 1.3.1.4 求出非严格递增数组中最后一个小于等于 `x` 的元素位置的算法代码

考虑到当 `x` 小于数组中所有元素时，数组中不存在符合要求的位置，所以需要提前判断然后返回-1。

```cpp
// 二分查找的过程与数组下标从0开始还是从1开始无关
// 数组 nums 为非严格递增数组，x 为待查找元素
int LastLe(const vector<int>& nums, int x)
{
    // num.back() 返回数组末尾的元素
    // 数组为空，或者 x 小于数组所有元素返回-1
    if (nums.size() == 0 || nums[0] > x) return -1;
    // 查找区间为 [left, right]，左闭右闭
    int left = 0, right = nums.size() - 1, mid;
    while (left <= right)
    {
        mid = (left + right) / 2;
        if (nums[mid] > x)      // 注意两者区别在这里
            right = mid - 1;    // 往左子区间 [left, mid - 1] 查找
        else left = mid + 1;    // 往右子区间 [mid + 1, right] 查找
    }

    return right;
}
```

# 2 二分法的实际应用

## 2.1 函数求根问题

给定一个定义在 $[L, R]$ 上的单调函数 $f(x)$，求方程 $f(x) = 0$ 的根，假设精度要求为 $eps = 10^{-5}$。

这种问题就可以用二分法来解决。因为函数 $f(x)$ 在 $[L, R]$ 上单调递增，所以可以将函数值当做一个**严格递增数组**，令 $left$ 和 $right$ 的初值分别为 $L$ 和 $R$，然后根据中间位置的函数值 $f(mid)$ 与 0 的大小关系来判断应往哪个子区间继续逼近 $f(x) = 0$ 的根：

- 如果 $f(mid)>0$，说明 $f(x) = 0$ 的根在 $mid$ 左边，应往 $[left, mid]$ 继续逼近，令 $right = mid$；
- 如果 $f(mid)<0$，说明 $f(x) = 0$ 的根在 $mid$ 右边，应往 $[mid, right]$ 继续逼近，令 $left = mid$。

需要注意的是，因为涉及的是到函数问题，我们的二分的对象是定义域，是一个实数域。所以在二分后，采取的是直接令左边界**等于 mid**，而不再进行加一或减一的操作。这不同于操作数组的下标，请仔细思考其中的区别。

```cpp
const double eps 1e-5;   // 精度为10^-5
double f(double x)          
{
    /*
    ・・・
    */
    return value;   // 返回 f(x) 的值
}

double Solve(double L, double R)
{
    double left = L, right = R, mid;
    while (right - left > eps)  // 当 right - left <= 10^-5 时结束循环
    {
        mid = (left + right) / 2;
        if (f(mid) > 0)         // 如果 f(x) 是单调递减函数，此处改为 f(mid) < 0
            right = mid;        // 往左子区间 [left, mid] 逼近
        else left = mid;        // 往右子区间 [mid, right] 逼近
    }

    return mid;     // 结束循环后的 mid 即为 f(x) = 0 的根
}
```

## 2.2 装水问题

有一个侧面看上去是半圆的储水装置，该半圆的半径为 $R$，要求往里面装入高度为 $h$ 的水，使其在侧面看去的面积 $S_1$ 与半圆面积 $S_2$ 的比例恰好为 $r$。如图所示，现在给定 $R$ 和 $r$，求高度 $h$，假设精度要求为 $eps = 10^{-5}$。

![alt text](./img/二分法-2.png)

显然，随着水面升高，面积比例 $r$ 一定是增大的。所以不妨这么做：在 $[0, R]$ 范围内对水面高度 $h$ 进行二分，计算在高度 $h$ 下的面积比例 $ratio$ 的值。

 - 如果 $ratio > r$，说明高度过高，应该减小高度（缩小右边界）；
 - 如果 $ratio < r$，说明高度过低，应该增大高度（增大左边界）。

```cpp
const double PI = acos(-1.0);   // 圆周率
const double eps = 1e-5;        // 精度
double f(double R, double h)	// 计算 r = f(h)，由实际含义可知 r 关于 h 递增
{
    double alpha = 2 * acos((R - h) / R);
    double L = 2 * sqrt(R * R - (R - h) * (R - h));
    double S1 = alpha * R * R / 2 - L * (R - h) / 2;
    double S2 = PI * R * R / 2;
    return S1 / S2;
}

double Solve(double R, double r)
{
    double left = 0, right = R, mid;
    while (right - left > eps)
    {
        mid = (left + right) / 2;
        if (f(R, mid) > r)  // 同样是实数域，所以不要加一减一
            right = mid;
        else left = mid;
    }
	
	return mid;
}
```

## 2.3 木棒切割问题

给出 $N$ 根木棒，长度均已知，现在希望通过切割它们来得到**至少** $K$ 段长度为 $L$ 的木棒（长度必须是整数），求 $L$ 可以取到的**最大值**。

举个栗子，假如有三根长度分别为10、24、15的木棒，如果至少需要得到 $K = 7$ 段长度相等的木棒，那么 $L$ 最长为6。因为它们分别可以提供 $10/6 = 1$ 段, $24/6 = 4$ 段, $15/6 = 2 $段。

首先可以注意到一个结论，如果 $L$ 越大，那么可以得到的木棒段数 $K$ 就越小。从这个角度出发便可以想到解决问题的思路：二分最大长度 $L$，根据当前能分割的木棒数 $k$ 与 $K$ 的大小关系来进行二分。

仔细考虑可以发现，该问题可等价于求**最后一个**满足条件 $k >= K$ 的长度 $L$。由前面可知，它可以转换为求**第一个**满足条件 $k < K$ 的长度 $L$，然后减一即可。所以基本思路是这样的：假设区间为左闭右闭的 $[left, right]$，传入的初值为 $[0, n]$，其中 $n$ 是 $N$ 根木棒中最长的长度。对当前长度 $L$ 来说，木棒段数 $k$ 为 $N$ 根木棒的长度分别除以 $L$ 后的商的和。

 - 如果 $k < K$，说明 $L$ 可能过大，应往减少 $L$（缩小右边界）；
 - 如果 $k >= K$，说明 $L$ 一定过小，则应增大 $L$（增大左边界）。

```cpp
// nums[] 为 N 根木棒长度递增排序后的数组
// 该函数计算在长度 L 下切割可得到的木棒数
int GetK(int L)  
{
    int sum = 0;
    for (int i = 0; i < N; ++i)
        sum += nums[i] / L;
    return sum;
}

// 二分区间为 [left, right]，传入的初值为 [0, n]
int Solve(int left, int right)
{
    int mid;
    while (left + 1 < right)
    {
        mid = (left + right) / 2;
        if (GetK(mid) < K)
            right = mid;
        else left = mid;
    }
    
    return right - 1;
}
```
## 2.4 快速幂问题

### 2.4.1 递归解决

现在有一个问题：给定三个正整数 $a、b、m(a<10^9, b<10^6,1<m<10^9)$，求 $a^b\%m$。

问题很简单，用一个循环就能做出来，但如果将每个数的范围调整一下，变成：$a、b、m(a<10^9, b<10^{18},1<m<10^9)$，求 $a^b\%m$。再用循环，一般的电脑我觉得都已经算不出来了。

在这里我们需要使用**基于二分思想**的快速幂的做法，因此也常被称为二分幂。快速幂基于以下事实：

 1. 对于任何非零的 $a$，都有 $a^b = a*a^{b-1}$。
 2. 如果 $b$ 是偶数，那么有 $a^b = a^{b/2}*a^{b/2}$。

显然，如果 $b$ 是奇数，总可以在下一步转换为 $b - 1$ 是偶数的情况，而 $b$ 是偶数的情况总可以在下一步转换为 $b/2$ 的情况。这样，在 $log_2(b)$ 级别次数的转换后，就可以把 $b$ 变为0，而任何正整数的0次方都是1。

举个例子，如果需要求 $2^{10}$：

 1. 10为偶数，所以 $2^{10} = 2^5*2^5$。
 2. 5为奇数，所以 $2^5 = 2*2^4$。
 3. 4为偶数，所以 $2^4 = 2^2*2^2$。
 4. 2为偶数，所以 $2^2 = 2^1*2^1$。
 5. 1为奇数，所以 $2^1 = 2*2^0$。
 6. $2^0 = 1$，然后从下往上依次回退计算即可。
 
 这显然是递归的思想，基于此便能得到快速幂的递归写法，时间复杂度为 $log_2(b)$。

```cpp
typedef long long LL;
LL BinaryPow(LL a, LL b, LL m)
{
    if (b == 0) return 1;   // 如果 b 为0，那么 a^0 = 1
    if (b % 2 == 1)         // 如果 b 为奇数，转化为偶数 b - 1
        return a * BinaryPow(a, b - 1, m) % m;
    else					// 如果 b 为偶数，转换为 b / 2
    {
        LL mul = BinaryPow(a, b / 2, m);
        return mul * mul % m;
    }
}
```

当 `b % 2 == 0` 时不能直接返回 `BinaryPow(a, b / 2, m) * BinaryPow(a, b / 2, m)`，而应当算出单个 `BinaryPow(a, b / 2, m)` 之后再相乘。这是因为前者每次都会调用两个 `BinaryPow` 函数，导致时间复杂度变成 $O(2^{log(b)}) = O(b)$。

例如求 `BinaryPow(8)` 时，会变成 `BinaryPow(4) * BinaryPow(4)`，而不是先计算 `BinaryPow(4)` 再乘2。之后，这两个 `BinaryPow(4)` 都会各自变成 `BinaryPow(2) * BinaryPow(2)`，于是就需要求四次 `BinaryPow(2)`；而每个 `BinaryPow(2)` 又会变成 `BinaryPow(1) * BinaryPow(1)`，因此最后需要求8次 `BinaryPow(1)`。

针对不同的题目，有两个细节可能需要注意：

 1. 初始时 `a` 有可能大于等于 `m`，那么需要在进入函数前就让 `a` 对 `m` 取模；
 2. 如果 `m` 为1，可以直接在函数外部特判为0，不需要进入函数来计算（因为**任何整数对1取模一定等于0**）。

### 2.4.2 迭代解决

对 $a^b$ 来说，如果把 $b$ 写成二进制，那么 $b$ 就可以写成若干二次幂之和。例如13的二进制是1101，于是3号位、2号位、0号位就都是1，那么就可以得到 $13=2^3+2^2+2^0 = 8 + 4 + 1$，所以 $a^{13} = a^{8+4+1} = a^8 * a^4*a^1$。

同理，我们可以把任意的 $a^b$ 表示成 $a^{2^k}、...\  、a^8、a^4、a^2、a^1$ 中若干项的乘积。其中，如果 $b$ 的二进制的 $i$ 号位为1，那么 $a^{2^i}$ 就被选中。于是可以得到计算 $a^b$ 的大致思路：令 $i$ 从0到 $k$ 枚举 $b$ 的每一个二进制位，如果当前位为1，那么累积 $a^{2^i}$。注意到 $a^{2^k}、...\  、a^8、a^4、a^2、a^1$ 的前一项总是等于后一项的平方，因此具体实现的时候可以这么做：

 1. 初始令 `ans` 等于1，用来存放累积的结果；
 2. 判断 `b` 的二进制位末尾是否为1（即判断 `b & 1` 是否为1，也可以理解为判断 `b` 是否为奇数），如果是的话，令 `ans` 乘上 `a` 的值；
 3. 将 `a` 平方，并将 `b` 右移一位（也可以理解为将 `b` 除以2），倒数第二位转为末位；
 4. 只要 `b` 大于0，就返回2。

```cpp
LL BinaryPow(LL a, LL b, LL m)
{
    LL ans = 1;
    while (b > 0)
    {
        if (b & 1)
            ans = ans * a % m;	// 令 ans 累积上 a
        a = a * a % m;			// 将 a 平方
        b >>= 1;				// 或写成 b = b >> 1 或 b = b / 2
    }
    return ans;
}

```
当 $b$ 等于13时，可以得到下表所示的模拟过程，b&1 用于判断 $b$ 的二进制末位。
|b|b&1| ans | $a$ |
|--|--|--|--|
|  |  | 1 | $a$ |
| 1101 | 1 | $1 * a = a$ | $a^2$ |
| 110 | 0 | $a$ | $a^4$ |
| 11 | 1 | $a * a^4 = a^5$ | $a^8$ |
| 1 | 1 | $a^5 * a^8 = a^{13}$ |  |

在实际应用中，递归写法和迭代写法在效率上的差别不那么明显。
