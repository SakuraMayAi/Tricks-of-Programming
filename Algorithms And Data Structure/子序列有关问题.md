# 0 子序列的概念

本文将介绍几种与子序列有关的典型问题。首先就需要了解什么是子序列。

给定一个序列 $seq$，**删除（或不删除）** 序列中的某些元素，且**不改变其余元素的顺序**而到的序列，我们称为 $seq$ 的**子序列**。序列 $seq$ 既可以是数组，也可以是字符串、集合等包含多个同类型元素的对象。

我会把每一个问题都具体化，并将序列 $seq$ 解释成一个具体的类型，从而能使读者更好的理解。但不管 $seq$ 是什么类型的序列，解答问题的思路和方法都是一样的。

本文会使用到的一些标记：

- $seq[i:]$ 表示序列 `seq` 中从下标 `i` 到**末**尾的子序列。
- $seq[:i]$ 表示序列 `seq` 中从**开头**到下标 `i` 的子序列。
- $seq[i : j]$ 表示序列 `seq` 中从下标 `i` 到下标 `j` 的子序列。

# 1 子序列是否存在问题

<details>
<summary>点击展开内容</summary>

## 1.1 问题概述

该问题可以简述为：给定字符串 $s$ 和 $t$ ，判断 $s$ 是否为 $t$ 的**子序列**。

## 1.2 解法一：贪心 + 双指针

### 1.2.1 匹配过程

定义两个指针 $i$ 和 $j$，分别指向字符串 $s$ 和 $t$ 的首字符。遍历两个字符串，并对 $s[i]$ 和 $t[j]$ 进行匹配。如果匹配成功，则 $i$ 和 $j$ 同时向后移，否则只有 $j$ 向后移。如果最终 $i$ 移动到了 $s$ 的末尾，说明 $s$ 中所有字符都匹配成功了，即表明 $s$ 是 $t$ 的子序列。

有一点要注意，对于 $s[i]$，在 $t$ 中可能不止一个位置可以匹配，那究竟是匹配哪一个呢？从贪心的策略来上，我们选择匹配**先出现的那个字符**。

假如 $s[i]$ 在 $t$ 中出现了两次，一个位置在 $j_1$，另一个在 $j_2$，且 $j_1 < j_2$。那么匹配 $t[j_1]$ 是更优的选择。因为在 $t[j_2]$ 后面出现的字符，同时也在 $t[j_1]$ 的后面；而先匹配 $t[j_1]$ 的话，在 $t[j_1]$ 和 $t[j_2]$ 之间就有更多的字符可以进行匹配，增大了匹配成功的概率。

### 1.2.2 C++ 代码

```cpp
bool Issubsequence(const string& s, const string& t)
{
    int i = 0;
    for (int j = 0; j < t.size(); ++j)
        if (s[i] == t[j]) ++i;

    return i == s.size();
}
```

## 1.3 解法二：动态规划 + 哈希表

问题升级一下：假如有大量输入的 $s$，称作 $s1$, $s2$, ... , $sk$ 其中 $k >= 10$ 亿，你需要依次检查它们是否为 $t$ 的子序列。在这种情况下，还采用解法一肯定会超时。不妨通过动态规划的方法，建立一个哈希表，再通过哈希表去匹配 `s` 中的每一个字符，速度就会快很多了。

### 1.3.1 确定 $dp[i][j]$ 的含义

这种类似于对同一个主串做很多次匹配的问题，可以像 $KMP$ 算法一样，先用一些时间将主串中的信息建立成一个哈希表，就可以快速的进行匹配。在这里，我们姑且将字符串 $t$ 称作**主串**。

假设主串 $t$ 的长度为 $n$。定义二维数组 $dp[n + 1][26]$，$dp[i][j]$ 表示主串 $t$ 中，从位置 $i$ 开始（包括 $i$ 在内）往后字符 $j$ **第一次出现**的位置。计算完 $dp$ 后，就能得到 $t$ 中从**每一个位置**开始往后**所有字符**第一次出现的位置。数组 $dp$ 也就是我们所说的哈希表。

由于需要记录后面的字符第一次出现的次数，所以需要采用**倒序遍历**。

### 1.3.2 确定边界条件

当 $i = n - 1$，除了位置 $n - 1$，再往后就没有任何字符了，无法继续匹配。因此可以令所有的 $dp[n][j] = n(0 \leq j < 26)$，这样就能正常匹配 $dp[n - 1][j]$。且当 $dp[i][j] = n$ 时，表明从 $i$ 开始往后不存在字符 $j$ 了，匹配结束。

### 1.3.3 推导 $dp[i][j]$

遍历主串 $t$，$0 \leq i \leq n - 1$：
- 若 $t[i]$ 处的字符就是 $j$，则 $dp[i][j] = i$。
- 若 $t[i]$ 处的字符不是 $j$，则从位置 $i$ 开始往后字符 $j$ 第一次出现的位置，等同于从位置 $i + 1$ 开始往后字符 $j$ 第一次出现的位置，所以 $dp[i][j] = dp[i + 1][j]$。

综上有：

$$
f[i][j]=\left\lbrace
\begin{array}{ll}
i, & t[i]=j \\
f[i+1][j], & t[i] \neq j
\end{array}\right.
$$

### 1.3.4 匹配过程

在循环中，定义两个指针 $i$ 和 $j$ 分别指向字符串 $t$ 和 $s$ 的首字符，$j$ 遍历字符串 $s$，$0 \leq j < s.size()$。

若 $d[i][s[j] - 'a'] = n$，说明往后没有字符可以匹配了，从而 $s$ 不是 $t$ 的子串，返回 $false$；若 $d[i][s[j] - 'a'] \neq n$，说明该处的字符与 $s[j]$ 匹配，则 $i$ 要跳转到该处的**下一个位置**，与 $s$ 的下一个位置（即 $j + 1$）进行匹配。

由于除了 $n$ 之外，$dp[i][j]$ 的最大值就是 $n - 1$，所以不用担心 $i = dp[i][j]$ 会出现越界的问题。循环能正常结束就说明字符串 $s$ 中的每一个字符都匹配成功了，返回 $true$。

### 1.3.5 C++ 代码

```cpp
bool Issubsequence(const string& s, const string& t)
{
    if (s.size() > t.size()) return false;  // s 比 t 更长，就不可能是 t 的子序列

    int n = t.size();
    vector<vector<int>> dp(n + 1, vector<int>(26, 0));
    for (auto& i : dp[n]) i = n;    // 初始化边界条件

    for (int i = n - 1; i >= 0; --i)
        for (int j = 0; j < 26; ++j)
            dp[i][j] = (t[i] == j + 'a') ? i : dp[i + 1][j];

    for (int i = 0, j = 0; j < s.size(); ++j)
    {
        if (dp[i][s[j] - 'a'] == n) // 到达主串末尾
            return false;
        i = dp[i][s[j] - 'a'] + 1;  // i 跳转到下一个位置进行匹配
    }

    return true;
}
```

</details>

# 2 最长递增子序列问题（Longest Increasing subsequence，LIs）

<details>
<summary>点击展开内容</summary>

该问题可以简述为：给定数组 $ary$，找到 $ary$ 中**递增子序列**的最大长度。

首先要明确一个概念，最长递增子序列**不一定唯一**，比如 $\{1,0,7,4\}$ 就有 ${1,7}$、${1,4}$ 和 ${0, 4}$ 三个最长递增子序列。与此同时，哪怕子数组 $ary[0:]$ 和 $ary[1:]$ 只差一个元素，所得到的最长递增子序列也不一定相同。

## 2.1 解法一：动态规划

### 2.1.1 确定 `dp[i]` 的含义

定义一维数组 `dp[ary.size()]`，`dp[i]` 表示在子序列 `ary[0:i]` 中，**以 `ary[i]` 结尾**的最长递增子序列的**长度**。

### 2.1.2 确定边界条件

由于一个元素就可以构成一个递增子序列，所以所有 `dp` 值初始时都为1。

### 2.1.3 推导 `dp[i]`

我们用 `s[i]` 表示子序列 $ary[0 : i]$ 中以 **`ary[i]` 结尾的**最长递增子序列。

遍历数组 `ary`，`1 <= i < ary.size()`，对于以 `ary[i]` 结尾的最长递增子序列的长度，需要根据子序列 `ary[0:i - 1]` 推导。

遍历子序列 `ary[0 : i - 1]`，`0 <= j < i`：
- 若 `ary[j] < ary[i]`，那么将 `ary[i]` 放到 `s[j]` 最后面，就可以构成一个新的递增子序列，即 `s[i]`，所以 `dp[i] = dp[j] + 1`；
- 若 `ary[j] \geq ary[i]`，`dp[i]` 维持不变。

也有可能，`ary[i]` 与另一个元素可以组成更长的递增子序列。所以 `dp[i]` 应该是两种情况下的最大值，从而有：

$$
dp[i] = max(dp[i],\ dp[j] + 1)
$$

`循环结束后，dp` 中保存的就是以各元素为结尾的最长递增子序列的长度。最终的结果是 `dp` 中的最大值，保存在 `len` 中。

### 2.1.4 C++ 代码

```cpp
int LengthOfLIS(const vector<int>& nums)
{
    vector<int> dp(nums.size(), 1);
    int len = 1;
    for (int i = 1; i < nums.size(); ++i)
    {
        for (int j = 0; j < i; ++j)
        {
            if (nums[j] < nums[i])  // 可以构成一个更长的递增子序列
            {
               dp[i] = max(dp[i], dp[j] + 1);
               len = max(len, dp[i]);
            }
        }
    }

    return len;
}
```

## 2.2 解法二：贪心 + 二分查找

### 2.2.1 贪心的应用和证明

考虑一个简单的贪心，我们往子序列中加入元素来寻找最长递增子序列。如果我们要使递增子序列**尽可能的长**，那我们就需要让序列递增得**尽可能的慢**。因此我们希望每次在递增子序列最后加上的那个数尽可能的小。

我们用 $s_i$ 表示**长度为** $i$ 的**任意递增子序列**，$s_i[i]$ 表示子序列中的**第 $i$ 个元素**（最后一个）；维护一个数组 $p$， $p[i]$ 表示**所有**长度为 $i$ 的递增子序列**末尾元素中的最小值**，易知 $s_i[i] \ge p[i] > s_i[i - 1]$。

> 所谓瘦死的骆驼比马大，因为 `s_i` 是递增的，所以即使 `p[i]` 是末尾元素中的最小值，它也一定大于 `s_i[i - 1]`。

首先，数组 $p$ 一定是递增的，证明如下：

1. 证明一：

假设数组 $p$ 不递增，则存在 $i > j$，使得 $p[i] < p[j]$。对于递增子序列 $s_i$，我们从末尾删除 $i - j$ 个元素，序列长度变为 $i - (i - j) = j$。设剩余的递增序列为 $s_j'$，其最后一个元素为 $x$，则有 $x < s_i[i - 1] < p[i] < p[j]$。因为 $s_j'$ 也是一个长度为 $j$ 的递增子序列，但它的末尾元素比 $p[j]$ 小，这与 $p[j]$ 的定义相矛盾。所以数组 $p$ 是递增的。

2. 证明二：

假设 $p[i]$ 是递增子序列 $s_i$ 的末尾元素，则有 $p[i] = s_i[i]$。因为 $s_i[i - 1] \ge p[i - 1]$，所以有 $p[i] = s_i[i] > s_i[i - 1] \ge p[i]$，即 $p[i] > p[i]$。因此，数组 $p$ 是递增的。

### 2.2.2 确定二分逻辑

定义 $len$ 保存当前最长递增子序列的长度，则 $p[len]$ 表示数组 $p$ 的末尾元素。遍历数组 $ary$，$1 <= i < ary.size()$：
- 如果 $ary[i]$ > $p[len]$，说明遇到了一个更长的递增序列，则把 $ary[i]$ 加入到数组 $p$，并更新 $len$；
- 如果 $ary[i] \leq p[len]$，说明其有可能是比某个递增子序列末尾元素**更小的元素**。在数组 $p$ 中进行**二分查找**，找到第一个比 $ary[i]$ 小的数的 `p[k]`，并更新 $p[k + 1] = ary[i]$。

> 或者说是找到第一个不小于 `ary[i]` 的数，即为要被更新的数。

第二点的原因如下：

如果 $ary[i] < p[len]$，且数组 $p$ 中存在 `k` 使得 $p[k] < ary[i] \le p[k + 1]$。那么说明以 $p[k + 1]$ 为末尾元素，长度为 $k + 1$ 的递增子序列，遇到了一个更小的末尾元素 $ary[i]$，所以需要更新 $p[k + 1]$ 为 $ary[i]$。

要注意的是，最终的数组 $p$，维护的并不一定是最长递增子序列。

### 2.2.3 C++ 代码

```cpp
int FindPos(const vector<int>& p, int len, int key)   // 返回数组 p 中第一个小于 key 的数的下标
{
    int left = 1, right = len, pos = 0;   // 找不到比 key 小的数时，返回0，表明更新数组 p 的第一个元素 p[0]
    while (left <= right)  // 二分查找
    {
        int mid = (left + right) >> 1;
        if (p[mid] < key)
        {
            pos = mid;
            left = mid + 1;
        }
        else right = mid - 1;
    }

    return pos;
}

int LengthOfLIS(const vector<int>& ary)
{
    int n = ary.size(), len = 1;
    vector<int> p(n + 1, 1);
    p[len] = ary[0];
    for (int i = 1; i < n; ++i)
    {
        if (ary[i] > p[len]) p[++len] = ary[i];
        else p[FindPos(p, len, ary[i]) + 1] = ary[i];
    }

    return len;
}
```

</details>

# 3 最长连续递增子序列问题

# 4 最长公共子序列问题

# 5 最长连续公共子序列问题

# 6 子序列个数问题
