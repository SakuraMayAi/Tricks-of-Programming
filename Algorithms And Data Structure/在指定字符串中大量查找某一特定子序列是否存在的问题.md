# 1 问题描述

给定字符串 `s` 和 `t` ，判断 `s` 是否为 `t` 的**子序列**。

字符串的一个子序列是指原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。例如，`"ace"` 是 `"abcde"` 的一个子序列，而 `"aec"` 不是。

假如如果有大量输入的 `s`，称作 `s1`, `s2`, ... , `sk` 其中 `k >= 10亿`，你需要依次检查它们是否为 `t` 的子序列。在这种情况下，如何解决？

# 2 通过动态规划建立哈希表

## 2.1 确定 `dp[i][j]` 的含义

我们姑且将字符串 `t` 称作**主串**。

这种类似于对同一个主串做很多次匹配的问题，可以像 `KMP` 算法一样，先用一些时间将主串中的信息建立成一个哈希表，就可以快速的进行匹配。

假设主串 `t` 的长度为 `n`。定义二维数组 `dp[n + 1][26]`，`dp[i][j]` 表示主串 `t` 中，从位置 `i` 开始往后字符 `j` 第一次出现的位置（包括位置 `i` 在内）。在计算完 `dp` 后，就能快速得到主串 `t` 中每一个位置 `i` 之后，下一个字符 `j` 出现的位置。这个数组 `dp` 就是我们所说的哈希表。

由于需要记录**后面的字符**第一次出现的次数，所以需要采用**倒序遍历**。

## 2.2 确定边界条件

当 `i = n - 1`，除了位置 `n - 1`，再往后就没有任何字符了。因此可以令任意的 `dp[n][j] = n(0 <= j < 26)`，这样就能正常匹配 `dp[n - 1][j]`。当 `dp[i][j] = n` 时，表明从 `i` 开始往后不存在字符 `j` 了，匹配结束。

## 2.3 推导 `dp[i][j]`

主串 `t`，`0 <= i <= n - 1`：
- 若 `t[i]` 处的字符就是 `j`，则 `dp[i][j] = i`。
- 若 `t[i]` 处的字符不是 `j`，则位置 `i` 开始往后字符 `j` 第一次出现的位置，等同于位置 `i + 1` 开始往后字符 `j` 第一次出现的位置，所以 `dp[i][j] = dp[i + 1][j]`。

综上有：

$$f[i][j]=\left\{\begin{array}{ll}
i, & t[i]=j \\
f[i+1][j], & t[i] \neq j
\end{array}\right.$$

## 2.4 匹配

匹配字符串 `s` 的过程是这样的：

在循环中，定义两个指针 `i` 和 `j` 分别指向字符串 `t` 和 `s` 的首字符，`j` 遍历字符串 `s`。

若 `d[i][s[j] - 'a'] = n`，说明往后没有字符可以匹配了，从而 `s` 不是 `t` 的子串，返回 `false`；若 `d[i][s[j] - 'a'] != n`，说明该处的字符与 `s[j]` 匹配，则 `i` 要跳转到该处的**下一个位置**，与 `s` 的下一个位置（即 `j + 1`）进行匹配。

由于 `dp[i][j]` 的最大值就是 `n`，所以不用担心 `i` 越界的问题。循环能正常结束就说明字符串 `s` 中的每一个字符都匹配成功了，返回 `true`。

## 2.4 C++ 算法代码

```cpp
bool IsSubsequence(const string& s, const string& t)
{
    int n = t.size();
    vector<vector<int>> dp(n + 1, vector<int>(26, 0));
    for (auto& i : dp[n]) i = n;    // 初始化边界条件

    for (int i = n - 1; i >= 0; --i)
        for (int j = 0; j < 26; ++j)
            dp[i][j] = (t[i] == j + 'a') ? i : dp[i + 1][j];

    for (int i = 0, j = 0; j < s.size(); ++j)
    {
        if (dp[i][s[j] - 'a'] == n) // 到达主串末尾
            return false;
        i = dp[i][s[j] - 'a'] + 1;  // i 跳转到下一个位置进行匹配
    }

    return true;
}
```
