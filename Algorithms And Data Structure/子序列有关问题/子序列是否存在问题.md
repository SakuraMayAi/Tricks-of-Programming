# 1 问题概述

该问题可以简述为：给定字符串 $s$ 和 $t$ ，判断 $s$ 是否为 $t$ 的**子序列**。

# 2 解法一：贪心 + 双指针

## 2.1 匹配过程

定义两个指针 $i$ 和 $j$，分别指向字符串 $s$ 和 $t$ 的首字符。遍历两个字符串，并对 $s[i]$ 和 $t[j]$ 进行匹配。如果匹配成功，则 $i$ 和 $j$ 同时向后移，否则只有 $j$ 向后移。如果最终 $i$ 移动到了 $s$ 的末尾，说明 $s$ 中所有字符都匹配成功了，即表明 $s$ 是 $t$ 的子序列。

有一点要注意，对于 $s[i]$，在 $t$ 中可能不止一个位置可以匹配，那究竟是匹配哪一个呢？从贪心的策略来上，我们选择匹配**先出现的那个字符**。

假如 $s[i]$ 在 $t$ 中出现了两次，一个位置在 $j_1$，另一个在 $j_2$，且 $j_1 < j_2$。那么匹配 $t[j_1]$ 是更优的选择。因为在 $t[j_2]$ 后面出现的字符，同时也在 $t[j_1]$ 的后面；而先匹配 $t[j_1]$ 的话，在 $t[j_1]$ 和 $t[j_2]$ 之间就有更多的字符可以进行匹配，增大了匹配成功的概率。

## 2.2 C++ 代码

```cpp
bool IsSubsequence(const string& s, const string& t)
{
    int i = 0;
    for (int j = 0; j < t.size(); ++j)
        if (s[i] == t[j]) ++i;

    return i == s.size();
}
```
</details>

# 3 解法二：动态规划 + 哈希表

<details>
<summary>点击展开内容</summary>

问题升级一下：假如有大量输入的 $s$，称作 $s_1$, $s_2$, ... , $s_k$，其中 $k \ge 10$ 亿，你需要依次检查它们是否为 $t$ 的子序列。在这种情况下，还采用解法一肯定会超时。不妨通过动态规划的方法，建立一个哈希表，再通过哈希表去匹配 $s$ 中的每一个字符，速度就会快很多了。

## 3.1 确定 $dp[i][j]$ 的含义

这种类似于对同一个主串做很多次匹配的问题，可以像 $KMP$ 算法一样，先用一些时间将主串中的信息建立成一个哈希表，就可以快速的进行匹配。在这里，我们姑且将字符串 $t$ 称作**主串**。

设主串 $t$ 的长度为 $n$。定义二维数组 $dp[n + 1][26]$, $dp[i][j]$ 表示主串 $t$ 中，从位置 $i$ 开始（包括 $i$ 在内）往后字符 $j$ **第一次出现**的位置。计算完 $dp$ 后，就能得到 $t$ 中从**每一个位置**开始往后**所有字符**第一次出现的位置。数组 $dp$ 也就是我们所说的哈希表。

由于需要记录后面的字符第一次出现的次数，所以需要采用**倒序遍历**。

## 3.2 确定边界条件

当 $i = n - 1$ 时，除了位置 $n - 1$，再往后就没有任何字符了，无法继续匹配。因此可以令所有的 $dp[n][j] = n(0 \le j < 26)$，这样就能正常匹配 $dp[n - 1][j]$。且当 $dp[i][j] = n$ 时，表明从 $i$ 开始往后不存在字符 $j$ 了，匹配结束。

## 3.3 推导 $dp[i][j]$

遍历主串 $t$, $n - 1 \ge i \ge 0$：
- 若 $t[i]$ 处的字符就是 $j$，则 $dp[i][j] = i$。
- 若 $t[i]$ 处的字符不是 $j$，则从位置 $i$ 开始往后字符 $j$ 第一次出现的位置，等同于从位置 $i + 1$ 开始往后字符 $j$ 第一次出现的位置，所以 $dp[i][j] = dp[i + 1][j]$。

综上有：

![image](https://github.com/user-attachments/assets/9eddb482-5885-42ba-9487-86e2d31522d2)

## 3.4 匹配过程

在循环中，定义两个指针 $i$ 和 $j$ 分别指向字符串 $t$ 和 $s$ 的首字符, $j$ 遍历字符串 $s$, $0 \le j < s.size()$。

若 $d[i][s[j] - 'a'] = n$，说明往后没有字符可以匹配了，从而 $s$ 不是 $t$ 的子串，返回 $false$；若 $d[i][s[j] - 'a'] \ne n$，说明该处的字符与 $s[j]$ 匹配，则 $i$ 要跳转到该处的**下一个位置**，与 $s$ 的下一个位置（即 $j + 1$）进行匹配。

由于除了 $n$ 之外, $dp[i][j]$ 的最大值就是 $n - 1$，所以不用担心 $i = dp[i][j]$ 会出现越界的问题。循环能正常结束就说明字符串 $s$ 中的每一个字符都匹配成功了，返回 $true$。

## 3.5 C++ 代码

```cpp
bool Issubsequence(const string& s, const string& t)
{
    if (s.size() > t.size()) return false;  // s 比 t 更长，就不可能是 t 的子序列

    int n = t.size();
    vector<vector<int>> dp(n + 1, vector<int>(26, 0));
    for (auto& i : dp[n]) i = n;    // 初始化边界条件

    for (int i = n - 1; i >= 0; --i)
        for (int j = 0; j < 26; ++j)
            dp[i][j] = (t[i] == j + 'a') ? i : dp[i + 1][j];

    for (int i = 0, j = 0; j < s.size(); ++j)
    {
        if (dp[i][s[j] - 'a'] == n) // 到达主串末尾
            return false;
        i = dp[i][s[j] - 'a'] + 1;  // i 跳转到下一个位置进行匹配
    }

    return true;
}
```
