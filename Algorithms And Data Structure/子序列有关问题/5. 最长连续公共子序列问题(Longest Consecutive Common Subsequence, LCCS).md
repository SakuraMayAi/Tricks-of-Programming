# 1 问题概述

该问题可以简述为：给定数组 $ary1$ 和 $ary2$，找到 $ary1$ 和 $ary2$ 的**连续公共子序列**的最大长度。

$LCS$ 问题在 $LCCS$ 问题的基础上，增加了“连续”这一限制条件，相对来说难度更小，要考虑的情况也更少。但是做法和 $LCS$ 问题基本是一致的。

# 2 解法：动态规划

## 2.1 确定 $dp[i][j]$ 的含义

设 $ary1$ 的长度为 m, $ary2$ 的长度为 $n$ 。定义二维数组 $dp[m + 1][n + 1]$, $dp[i][j]$ 表示子序列 $ary1[i:]$ 和 $ary2[j:]$ **最长连续公共前缀**的长度。

以 $ary1 = \lbrace 1,2,3,2,1 \rbrace$, $ary2 = \lbrace 3,2,1,4,7 \rbrace$ 为例。当 $i = 2$, $j = 0$ 时, $dp[2][0]$ 表示的是子序列 $ary1[2:4] = \lbrace 3,2,1 \rbrace$ 和 $ary2[0:4] = \lbrace 3,2,1,4,7 \rbrace$ 的最长连续公共前缀的长度。这个最长连续公共前缀是 $\lbrace 3,2,1 \rbrace$，所以 $dp[2][0] = 3$。

暴力解法下，需要从前往后遍历两个数组，此时要考虑所有子序列的情况，并判断其中是否存在相同的子序列。而这个比较过程会多次计算重复的子序列，容易导致超时。即便通过去重的方式进行剪枝，剪枝这个操作本身还是会占用一定时间，当数组比较大时，即使是剪枝也治标不治本。

如果我们从后向前遍历两个数组的所有元素，对于子序列 $ary1[i:]$ 和 $ary2[j:]$ 的公共前缀，在整个数组中来看，其实就是一个**公共子序列**。因为子序列的起始位置不同，构成的前缀也不同，从而就避免了计算重复的情况。而且通过已经计算过的连续公共前缀的长度，可以快速得到下一个子序列的连续公共前缀的长度。

## 2.2 确定边界条件

边界条件无需单独计算，放到循环即可。所有 $dp$ 初始值为0，表明公共前缀长度为0。

## 2.3 推导 $dp[i][j]$

外层循环遍历数组 $ary1$, $m - 1 \ge i \ge 0$；内层循环遍历数组 $ary2$, $n - 1 \ge j \ge 0$：
- 若 $ary2[j] \ne ary1[i]$，表明两个子序列的首元素不相等，也就不存在公共前缀，继续遍历即可；
- 若 $ary2[j] = ary1[i]$，表明两个子序列的首元素相等，此时需要考虑是否能使得公共前缀更长，可以由 $dp[i + 1][j + 1]$ 推导。

设 $ary1[i + 1:]$ 和 $ary2[j + 1:]$ 的最长连续公共前缀（最长连续公共子序列）为 $s$，因为 $ary1[j] = ary2[i]$，因此 $ary1[i] + s$ 就可以构成一个更长的连续公共前缀。又因为 $dp[i + 1][j + 1]$ 表示子序列 $ary1[i + 1:]$ 和 $ary2[j + 1:]$ **最长连续公共前缀**的长度，所以可以得到：

$$dp[i][j] = dp[i + 1][j + 1] + 1$$

最终的结果就是 $dp$ 中的最大值，保存在 $len$ 中。

## 2.4 C++ 代码

```cpp
int LengthOfLCCS(const vector<int>& ary1, const vector<int>& ary2)
{
    int m = ary1.size(), n = ary2.size(), len = 0;
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    for (int i = m - 1; i >= 0; --i)
    {
        for (int j = n - 1; j >= 0; --j)
        {
            if (ary2[j] == ary1[i])
            {
                dp[i][j] = dp[i + 1][j + 1] + 1;
                len = max(len, dp[i][j]);   // 出现相等前缀时再更新 len，减少比较时间
            }
        }
    }

    return len;
}
```

## 2.5 优化：空间复杂度

以 $ary1$ 为行遍历, $ary2$ 为列遍历时，遍历的顺序是由右往左，由下往上的。由于 $dp[i][j]$ 只和下一行的 $dp[i + 1][j + 1]$ 有关，所以我们可以只保存下一行的 $dp$ 值。在进入内层循环前定义一维数组 $newDp$，来保存更新后的 $dp$，在内层循环结束后将其拷贝给 $dp$。结束循环后 $dp$ 保存的就是原 $dp[m + 1][n + 1]$ 中最后一行的信息，而最大值保存在 $len$ 中。

```cpp
int LengthOfLCCS(const vector<int>& ary1, const vector<int>& ary2)
{
    int m = ary1.size(), n = ary2.size(), len = 0;
    vector<int> dp(n + 1, 0);
    for (int i = m - 1; i >= 0; --i)
    {
        vector<int> newDp(n + 1, 0);
        for (int j = n - 1; j >= 0; --j)
        {
            if (ary2[j] == ary1[i])
            {
                newDp[j] = dp[j + 1] + 1;
                len = max(len, newDp[j]);
            }
        }
        dp = newDp;
    }

    return len;
}
```
