# 1 概述

最大回文子串问题($Longest\ Palindromic\ Substring\ Problem,\ LPSP$)，指的是寻找给定字符串中的**最长回文子串**。回文串是指一个字符串正读和反读都一样的字符串，比如 $"madam"$ 或 $"racecar"$；而子串指的是字符串中由**连续字符**组成的一个子序列。

这个问题可以通过多种方法解决，包括暴力法、动态规划、中心扩展法以及 $Manacher$ 算法，本文将介绍后面三种解法。

# 2 解法一：动态规划

## 2.1 确定 $dp[i][j]$ 的含义

设给定字符串 $s$ 的长度为 $n$，定义二维数组 $dp[n][n]$, $dp[i][j]$ 表示子串 $s[i:j]$ **是否为回文串**。由 $dp[i][j]$ 的含义可知, $j \ge i$，表明我们只计算 $dp$ 的上三角区域。

## 2.2 确定边界条件

对于 $s$ 中的每一个字符而言，其单独都是一个回文子串，所以对于任意的 $0 \le i \le n$，都有 $dp[i][i] = true$。也即，对角线上的 $dp$ 值都是 $true$。

## 2.3 推导 $dp[i][j]$

基本思路是先固定 $i$，然后 $j$ 遍历 $i$ 之后的每一个字符，此时 $i$ 和 $j$ 刚好划分出一个子串，我们就判断 $s[i:j]$ 是否为回文子串。

遍历字符串 $s$, $0 \le i \le j$；遍历子串 $s[j:]$, $i + 1 \le j \le n$：
- 如果 $s[j] \ne s[i]$，那么 $s[i:j]$ 一定不是回文子串，所以 $dp[i][j]$ = true。
- 如果 $s[j] = s[i]$，那么 $s[i:j]$ 是否为回文子串，取决于 $s[i + 1:j - 1]$ 是否为回文子串（也就是夹在 $i$ 和 $j$ 中间的子串），所以 $dp[i][j] = dp[i + 1:j - 1]$；

但在这里有一个特殊情况，那就是当 $i$ 和 $j$ 相邻时会访问出错。比如 $s[0:1] = "aa"$，则 $dp[i + 1:j - 1] = dp[1:0]$，属于下三角，不符合我们一开始的定义。所以在计算 $dp$ 前，需要先判断字符串中所**有相邻字符**构成的子串是否为回文串。

读者不知道有没有发现，我们是顺序遍历的，因此 $dp[i + 1][]$ 一定是在 $dp[i]$ 之后才计算出来的。但 $dp[i][]$ 的值取决于 $dp[i + 1][j - 1]$，后者的值尚不确定，怎么计算前者的值呢？解决办法很简单，我们只需要倒序遍历，先计算 $dp[i + 1]$ 即可，后续所有的 $dp[i]$ 的值就都能计算出来了。

每找到一个新的回文子串，就将 $len$ 与其长度进行比较，最终 $len$ 保存的就是字符串 $s$ 中最大回文子串的长度。

```cpp
int LengthOfLPS(const string& s)
{
    int n = s.size();
    vector<vector<bool>> dp(n, vector<bool>(n, false));
    for (int i = 0; i < n; ++i) dp[i][i] = true;    // 对角线上的 dp 值都是 true
    int len = 1;
    for (int i = 0; i < n - 1; ++i)
    {
        if (s[i] == s[i + 1])
        {
            dp[i][i + 1] = true;  // 判断所有相邻的字符是否为回文子串
            len = max(len, 2);
        }
    }
    for (int i = n - 2; i >= 0; --i)
    {
        for (int j = i + 2; j < n; ++j)
        {
            if (s[j] == s[i]) dp[i][j] = dp[i + 1][j - 1];
            if (dp[i][j]) len = max(len, j - i + 1);
        }
    }
    
    return len;
}
``` 

# 3 解法二：双指针 + 中心扩展

## 3.1 思路

通常来说，判断一个字符串是否为回文串的方法可以使用双指针法。使用**两个指针**，分别指向字符串的**首字符**和**尾字符**，当两个指针指向的字符相同时，就同时**向字符串的中心**移动。如果最后两个指针能相遇，就说明字符串是回文串。

现在需要找出字符串中的最大回文子串。如果我们暴力枚举所有的子串，再依次判断是否为回文子串，在面对比较长的字符串时明显不是一个很合适的做法。倘若我们换个方向，让两个指针从字符串的**中心同时向两侧扩展**，当两个指针指向的元素相同时就继续扩展，否则停止扩展。两个指针每扩展一次，以这两个指针为首字符和尾字符的子串，就是一个新的回文子串。

如何确定字符串的中心呢？我们首先需要了解到，它是需要根据字符串长度确定的。比如字符串 $s1 = "abbca"$ 的长度是奇数，其中心就是下标为2的位置；而字符串 $s2 ="cabaca"$ 的长度是偶数，其中心就有两个，分别是下标为2和下标为3的位置。因此，对于给定的字符串 $s$ 来说，**每一个字符**，和**每一对相邻的字符**，都有可能成为一个回文子串的中心。

如何确定谁会成为中心呢？在不确定子串长度的情况下，实际上我们很难确定。因为我们的目的是寻找最大回文子串，而不是确定一个子串然后判断其是否回文。所以每一个字符、和每一对相邻的字符，我们都需要考虑其作为中心时的最长回文子串。

因此做法就是：遍历字符串 $s$, $0 \le i < n$, $n$ 为 $s$ 的长度。然后分别以 $i$ 为中心，和以 $i$ 和 $i + 1$ 为中心，通过指针同时向两侧扩展，寻找最长回文子串。

## 3.2 C++ 代码

```cpp
int GetMaxLength(const string& s, int left, int right, int n)
{
    while (left >= 0 && right < n && s[left] == s[right])
    {
        --left;
        ++right;
    }

    return right - left - 1;    // 结束循环后，回文子串 = s[left : right]，不包括两端字符
}

int LengthOfLPS(const string& s)
{
    int len = 0, n = s.size();  // len 保存最大回文子串的长度
    for (int i = 0; i < n; ++i)
    {
        int tmp = max(GetMaxLength(s, i, i, n), GetMaxLength(s, i, i + 1, n));
        len = max(len, tmp);
    }

    return len;
}
```

# 4 解法三: $Manacher$ 算法

$Manacher$ 算法（马拉车算法）是一种用于查找字符串中**最大回文子串**的**线性时间复杂度**算法 $Manacher$ 算法的特别之处在于它能够在线性时间 $O(n)$ 内完成这一任务，这比传统的动态规划或中心扩展方法更高效，后者的时间复杂度通常为 $O(n^2)$。

## 4.1 预处理

*Manacher* 算法也会面临解法二中字符串长度为奇数和偶数时，中心不确定的情况。它的处理方式是在**字符串的两边**和**所有相邻的字符中间**插入原字符串中**不存在的字符**。

通常的做法是插入字符 $'\\#'$，比如字符串 $"abaa"$ 就会被处理成 $"\\# a \\# b \\# a \\# a \\#"$。但不管**原字符串和回文子串**的长度是奇数还是偶数，**插入字符的个数总是比其长度多1**，因此得到的字符串和回文子串的长度也总是奇数。

比如回文子串 $"aba"$ 经过处理后就是 $"\\# a \\# b \\# a \\#"$，长度仍然为奇数；回文子串 $"abba"$ 经过处理后就是 $"\\# a \\# b \\# b \\# a \\#"$，长度还是奇数。这样，由新回文子串的长度得到原本回文子串的长度，只需**除2然后向下取整**。

而为了防止在扩展回文子串的时候访问字符串越界，可以在预处理后的字符串**开头**添加一个字符 $'\\$'$，在**末尾**添加一个字符 $'!'$。这样开头和结尾的两个字符一定不相等，循环就可以在这里终止。

## 4.2 维护数据

### 4.2.1 数组 $f$

设处理前的字符串为 $s$；经过处理后的字符串为 $t$。

维护一个数组 $f$, $f[i]$ 表示以 $t$ 的第 $i$ 个字符为中心，可以扩展出的**最大回文半径**（从第 $i$ 个字符开始到最长回文子串端点的距离）。

> 要注意，**最大回文子串**指的是以所有点为中心的**最长回文子串**中，**长度最大**的那一个。

设在 $s$ 中，以字符 $t[i]$ 为中心的**最长回文子串**的长度为 $L$。由预处理的过程知道，插入字符的个数总是比长度多1。所以在 $t$ 中以 $t[i]$ 为中心的**最长回文子串**的长度为 $L + (L + 1) = 2 \times L + 1$。而第 $i$ 个字符的最大回文半径为 $f[i]$，由半径得到的**最长回文子串**的长度是 $2 \times L  - 1$。因此有 $2 \times L + 1 = 2 \times L  - 1$，从而可以解得 $L = f[i] - 1$。

因此, $f[i] - 1$ 就表示在 $s$ 中，以 $t[i]$ 为中心的**最长回文子串**的长度。

### 4.2.2 $i_m$ 和 $r_m$

对于第 $i$ 个字符，如果我们知道它对应的 $f[i]$，就能知道以它为中心的**最长回文子串**的**尾字符的下标**是 $i + f[i] − 1$，后面简称为**右端点**。比如当 $f[4] = 5$ 时，说明以第4个字符为中心，可以扩展出的**最大回文半径**是5，因此右端点为 $4 + 5 − 1 = 8$。

假设我们已经计算出了子串 $f[1:i − 1]$ 内**所有点**的 $f$ 值，那么我们就能得到子串 $f[1:i − 1]$ 中所有的**最长回文子串**的右端点。 $Manacher$ 算法依旧需要遍历 $s$ 的每一个字符，并假设它是回文子串的中心。但是它会利用已经计算出来的 $f[1:i - 1]$ 中的状态来更新 $f[i]$，而不是像解法二一样盲目地扩展。它要求我们维护一个**当前最大回文子串**的右端点 $r_m$，以及这个**最大回文子串**的中心 $i_m$。

## 4.3 初始化 $f[i]$

遍历字符串 $t$, $1 \le i < n$, $n$ 是字符串 $t$ 的大小。当我们遍历到 $f[i]$ 时，首先要做的是初始化 $f[i]$。
- 如果 $i \le r_m$，设 $j$ 是 $i$ 关于 $i_m$ 的对称点，即 $i - i_m = i_m - j$。则有 $f[i] = min \lbrace f[j],\ r_m - i + 1 \rbrace$；
- 如果 $i > r_m$，则 $f[i] = 1$。

解释一下为什么 $f[i] = min \lbrace f[j], r_m - i + 1 \rbrace$：

如下所示，设以 $i_m$ 为中心的**最大回文子串**的右端点为 $r_m$，左端点为 $l_m$。如果 $i < r_m$，说明 $i$ 被包含在以 $i_m$ 为中心的**最大回文子串**中。我们已知 $j$ 和 $i$ 关于 $i_m$ 对称，则有 $j + i = 2 \times i_m$。

$$t:\ l_m\ ....\ j\ ........\ i_m\ ........\ i\ ....\ r_m$$

- 情况一

如下所示，如果以 $j$ 为中心的**最长回文子串**的左端点 $y \ge l_m$，说明 $y$ 也被包含在以 $i$ 为中心的**最大回文子串**中。这说明 $t[j : i]$ 是一个以 $i_m$ 为中心的**回文子串**，且有 $t[i] = t[j]$。

而我们已经知道了以 $j$ 为中心的**最长回文子串**的半径是 $f[j] = j_r - j$，因此以 $i$ 为中心的**最长回文串至少等于**以 $j$ 为中心的**最长回文子串**（因为 $j$ 和 $i$ 关于 $i_m$ 对称），所以有 $f[i] \ge f[j]$。

$$t:\ l_m\ ..\ y\ ....\ j\ ....\ y\ ........\ i_m\ ........\ y\ ....\ i\ ....\ y\ ..\ r_m$$

- 情况二

如下所示，如果以 $j$ 为中心的**最长回文子串**的左端点 $y < l_m$，说明 $y$ 不在以 $i$ 为中心的**最大回文子串**中。此时有 $r_m - i + 1 = j - l_m + 1 < j - y = f[j]$。尽管 $j$ 和 $i$ 关于 $i_m$ 对称，但是以 $i$ 为中心的**最长回文子串**不一定等于以 $j$ 为中心的**最长回文子串**。但它至少等于 $r_m - i + 1$，所以有 $f[i] = r_m - i + 1$。

$$t:y..\ l_m\ ....\ j\  ........\ i_m\ ........\ i\ ....\ r_m$$

综上有：

$$f[i] = min(f[j],\ r_m - i + 1)$$

## 4.4 中心扩展

由上一小节的推导我们可以知道，在初始化 $f[i]$ 后，以 $i$ 为中心的**最长回文子串**的左右端点分别是 $t[i - f[i] + 1]$, $t[i + f[i] - 1]$ 且两者相等。现在要做的就是**同时向两边扩展**这个回文子串的长度，做法和中心扩展屎一样的。为了防止下标越界，在预处理字符串时，就在 $t$ 的最左侧加上字符 $'\\$'$，最右侧加上字符 $'!'$，即可保证循环在这里结束。

通过上述方法，我们就能得到字符串 $s$ 中，以所有点为中心的**最长回文子**串的半径，也就能够得到以所有点为中心的最长回文子串中，最大的长度，即**最大回文子串**。

## 4.5 C++ 代码

```cpp
int LengthOfLPS(const string& s)
{
    int n = s.size() * 2 + 3;   // L + (L + 1) + 首尾两个字符
    string t(n, '#');           // t 初始化为全 '#'
    t[0] = '$', t[n - 1] = '!'; // 修改首字符和尾字符
    for (int i = 2, j = 0; i < n; i += 2)
        t[i] = s[j++];  // 间隔插入 s 中的字符
    
    vector<int> f(n, 0);
    int im = 0, rm = 0, len = 0;    // len 保存最大回文子串的长度
    for (int i = 1; i < n; ++i)
    {
        f[i] = (i <= rm) ? min(rm - i + 1, f[2 * im - i]) : 1; // 初始化 f[i]
        while (t[i - f[i]] == t[i + f[i]]) ++f[i];  // 中心扩展，最大回文半径变大
        if (i + f[i] - 1 > rm)  // 更新 im 和 rm
        {
            im = i;
            rm = i + f[i] - 1;
        }
        len = max(len, f[i] - 1);   // 更新当前最大回文子串的长度
    }
    
    return len;
}
```
